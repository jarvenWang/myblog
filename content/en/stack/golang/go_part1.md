---
author: "wangjinbao"
title: "学习go(第一部分)"
date: 2021-01-03 01:01:00
description: "go语言起源、安装运行环境、编辑器、集成等"
draft: false
hideToc: false
enableToc: true
enableTocContent: false
author: wangjinbao
authorEmoji: 👻
tags: 
- golang
- categories:

---


## 一、起源与发展
### 起源
Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：
+ Robert Griesemer（参与开发 Java HotSpot 虚拟机）
+ Rob Pike（Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言）
+ Ken Thompson（贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范）
### 时间轴：
+ 2007 年 9 月 21 日：雏形设计
+ 2009 年 11 月 10日：首次公开发布
+ 2010 年 1 月 8 日：当选 2009 年年度语言
+ 2010 年 5 月：谷歌投入使用
+ 2011 年 5 月 5 日：Google App Engine 支持 Go 语言
### 为什么要创造一门编程语言
+ C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。
+ 对比计算机性能的提升，软件开发领域不被认为发展地足够快或者比硬件发展更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。
+ 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。
### Go 语言的发展目标
Go 语言的主要目标 ：

将 <font color="pink">静态语言的 安全性 和 高效性 </font> 与 <font color="pink">动态语言的 易开发性</font> 进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。
因此，Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。

Go 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机，这一点对于谷歌内部的使用来说就非常重要了。设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。

这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。

Go 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。这不仅极大地提升了开发者的生产力，同时也使得软件开发过程中的代码测试环节更加紧凑，而不必浪费大量的时间在等待程序的构建上。

<font color="pink">依赖管理 </font>  是现今软件开发的一个重要组成部分，但是 C 语言中“头文件”的概念却导致越来越多因为依赖关系而使得构建一个大型的项目需要长达几个小时的时间。人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。

整个 Go 语言标准库的编译时间一般都在 20 秒以内，其它的常规项目也只需要半秒钟的时间来完成编译工作。这种闪电般的编译速度甚至比编译 C 语言或者 Fortran 更加快，使得编译这一环节不再成为在软件开发中困扰开发人员的问题。在这之前，动态语言将快速编译作为自身的一大亮点，像 C++ 那样的静态语言一般都有非常漫长的编译和链接工作。而同样作为静态语言的 Go 语言，通过自身优良的构建机制，成功地了去除了这个弊端，使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。

另外，Go 语言在执行速度方面也可以与 C/C++ 相提并论。

由于内存问题（通常称为内存泄漏）长期以来一直伴随着 C++ 的开发者们，Go 语言的设计者们认为内存管理不应该是开发人员所需要考虑的问题。因此尽管 Go 语言像其它静态语言一样执行本地代码，但它依旧运行在某种意义上的虚拟机，以此来实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。

尽管垃圾回收并不容易实现，但考虑这将是未来并发应用程序发展的一个重要组成部分，Go 语言的设计者们还是完成了这项艰难的任务。

Go 语言还能够在运行时进行反射相关的操作。

使用 <font color="pink">go install</font>  能够很轻松地对第三方包进行部署。

此外，Go 语言还支持调用由 C 语言编写的海量库文件（第 3.9 节），从而能够将过去开发的软件进行快速迁移。

### 关于特性缺失
许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。
+ 为了简化设计，不支持函数重载和操作符重载
+ 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换
+ Go 语言通过另一种途径实现面向对象设计来放弃类和类型的继承
+ 尽管在接口的使用方面可以实现类似变体类型的功能，但本身不支持变体类型
+ 不支持动态加载代码
+ 不支持动态链接库
+ 不支持泛型
+ 通过 recover 和 panic 来替代异常机制
+ 不支持断言
+ 不支持静态变量
### 必杀技
+ 简化问题，易于学习
+ 内存管理，简洁语法，易于使用
+ 快速编译，高效开发
+ 高效执行
+ 并发支持，轻松驾驭
+ 静态类型
+ 标准类库，规范统一
+ 易于部署
+ 文档全面
+ 免费开源

## 二、安装与运行环境
Go 语言开发团队开发了适用于以下操作系统的编译器：
+ Linux
+ FreeBSD
+ Mac OS X（也称为 Darwin）

目前有2个版本的编译器：<font color="pink">Go 原生编译器 gc</font> 和 <font color="pink">非原生编译器 gccgo</font>，这两款编译器都是在类 Unix 系统下工作 。其中，gc 版本的编译器已经被移植到 Windows 平台上，并集成在主要发行版中，你也可以通过安装 MinGW 从而在 Windows 平台下使用 gcc 编译器。这两个编译器都是以单通道的形式工作。

你可以获取以下平台上的 Go 1.4 源码和二进制文件：

+ Linux 2.6+：amd64、386 和 arm 架构
+ Mac OS X（Snow Leopard + Lion）：amd64 和 386 架构
+ Windows 2000+：amd64 和 386 架构

### 1、Go 原生编译器 gc：

主要基于 Ken Thompson 先前在 Plan 9 操作系统上使用的 C 工具链。

Go 语言的编译器和链接器都是使用 C 语言编写并产生本地代码，Go 不存在自我引导之类的功能。因此如果使用一个有不同指令集的编译器来构建 Go 程序，就需要针对操作系统和处理器架构（32 位操作系统或 64 位操作系统）进行区别对待。

这款编译器使用非分代、无压缩和并行的方式进行编译，它的编译速度要比 gccgo 更快，产生更好的本地代码，但编译后的程序不能够使用 gcc 进行链接。

### 2、gccgo 编译器：
一款相对于 gc 而言更加传统的编译器，使用 GCC 作为后端。GCC 是一款非常流行的 GNU 编译器，它能够构建基于众多处理器架构的应用程序。编译速度相对 gc 较慢，但产生的本地代码运行要稍微快一点。它同时也提供一些与 C 语言之间的互操作性。

从 Go 1 版本开始，gc 和 gccgo 在编译方面都有等价的功能。
 
### 3、Go 环境变量
Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之间就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：
+ <font color="pink">$GOROOT</font> 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。
+ <font color="pink">$GOARCH</font>  表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm<font color="pink">(苹果M1 芯片)</font>。
+ <font color="pink">$GOOS</font>  表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。
+ <font color="pink">$GOBIN</font>  表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。

为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置目标机器的参数，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。

+ <font color="pink">$GOPATH</font> 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你<font color="pink">必须修改为其它路径</font>。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又<font color="pink">必须分别包含三个规定的目录：src、pkg 和bin</font>，这三个目录分别用于存放源码文件、包文件和可执行文件。
+ <font color="pink">$GOARM</font> 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。
+ <font color="pink">$GOMAXPROCS</font> 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节

### 4、linux安装
传送门：[/en/stack/golang/install_linux/](/en/stack/golang/install_linux/)
### 5、mac安装
传送门：[/en/stack/golang/get_started/](/en/stack/golang/get_started/)
### 6、调试器
1、<font color="pink">dlv</font> 
```shell
dlv debug --headless --listen=:2345 --log --api-version 2
```
2、在 <font color="pink">fmt.Printf</font> 中使用下面的说明符来打印有关变量的相关信息：
+ <font color="pink">%+v</font> 打印包括字段在内的实例的完整信息
+<font color="pink">%#v</font> 打印包括字段和限定类型名称在内的实例的完整信息
+ <font color="pink">%T</font> 打印某个类型的完整说明

3、<font color="pink">panic</font> 语句
4、关键字 <font color="pink">defer</font> 来跟踪代码执行过程

### 7、构建并运行 Go 程序
从 Go 1 版本开始，使用 Go 自带的更加方便的工具来构建应用程序：

+ <font color="pink">go build</font> 编译并安装自身包和依赖包
+ <font color="pink">go install</font> 安装自身包和依赖包

Go语言是 <font color="pink">编译型</font> 的 <font color="pink">静态语言</font>（和C语言一样），所以在运行Go语言程序之前，先要将其编译成二进制的可执行文件。

#### go build:
可以将Go语言程序代码编译成二进制的可执行文件，但是需要我们手动运行该二进制文件；

go build 命令用来启动编译，它可以将Go语言程序与相关依赖编译成一个可执行文件，其语法格式如下。
go build <font color="pink">fileName</font> 其中 fileName 为所需要的参数，可以是一个或者多个 Go 源文件名（当有多个参数时需要使用空格将两个相邻的参数隔开），也可以省略不写。

使用 go build 命令进行编译时，不同参数的执行结果也是不同的。
如编译打包linux <font color="pink">生产环境</font> 的包：
```shell
GOOS=linux GOARCH=amd64 GIN_MODE=release go build main.go
```
1. 当参数不为空时如果 fileName 为同一 main 包下的所有源文件名（可能有一个或者多个），编译器将生成一个与第一个 fileName 同名的可执行文件（如执行
   go build abc.go def.go ...会生成一个 abc.exe 文件）；如果 fileName 为非 main 包下的源文件名，编译器将只对该包进行语法检查，不生成可执行文件。
2. 当参数为空时如果当前目录下存在 main 包，则会生成一个与当前目录名同名的“目录名.exe”可执行文件（如在 hello 目录中执行 go build命令时，会生成 hello.exe 文件）；如果不存在 main 包，则只对当前目录下的程序源码进行语法检查，不会生成可执行文件。

#### go run
更加方便，它会在编译后直接运行Go语言程序，编译过程中会产生一个临时文件，但不会生成可执行文件，这个特点很适合用来调试程序。

go run命令将编译和执行指令合二为一，会在编译之后立即执行Go语言程序，但是不会生成可执行文件。

go run命令的语法格式如下：
```shell
go run fileName
```
其中 fileName 为所需要的参数，参数必须是同一 main 包下的所有源文件名，并且不能为空。

### 8、其它工具
Go 自带的工具集主要使用脚本和 Go 语言自身编写的，目前版本的 Go 实现了以下三个工具：

+ <font color="pink">go install</font> 是安装 Go 包的工具，类似 Ruby 中的 rubygems。主要用于安装非标准库的包文件，将源代码编译成对象文件。
+ <font color="pink">go fix</font> 用于将你的 Go 代码从旧的发行版迁移到最新的发行版，它主要负责简单的、重复的、枯燥无味的修改工作，如果像 API 等复杂的函数修改，工具则会给出文件名和代码行数的提示以便让开发人员快速定位并升级代码。Go 开发团队一般也使用这个工具升级 Go 内置工具以及 谷歌内部项目的代码。go fix 之所以能够正常工作是因为 Go 在标准库就提供生成抽象语法树和通过抽象语法树对代码进行还原的功能。该工具会尝试更新当前目录下的所有 Go 源文件，并在完成代码更新后在控制台输出相关的文件名称。
+ <font color="pink">go test</font> 是一个轻量级的单元测试框架

### 9、与 C 进行交互
工具 cgo 提供了对 FFI（外部函数接口）的支持，能够使用 Go 代码安全地调用 C 语言库，你可以访问 cgo 文档主页：http://golang.org/cmd/cgo。cgo 会替代 Go 编译器来产生可以组合在同一个包中的 Go 和 C 代码。在实际开发中一般使用 cgo 创建单独的 C 代码包。

如果你想要在你的 Go 程序中使用 cgo，则必须在单独的一行使用 import "C" 来导入，一般来说你可能还需要 import "unsafe"。

然后，你可以在 import "C" 之前使用注释（单行或多行注释均可）的形式导入 C 语言库（甚至有效的 C 语言代码），它们之间没有空行，例如：
```golang
// #include <stdio.h>
// #include <stdlib.h>
import "C"
```

名称 "C" 并不属于标准库的一部分，这只是 cgo 集成的一个特殊名称用于引用 C 的命名空间。在这个命名空间里所包含的 C 类型都可以被使用，例如 C.uint、C.long 等等，还有 libc 中的函数 C.random() 等也可以被调用。

当你想要使用某个类型作为 C 中函数的参数时，必须将其转换为 C 中的类型，反之亦然，例如：
```golang
var i int
C.uint(i)       // 从 Go 中的 int 转换为 C 中的无符号 int
int(C.random()) // 从 C 中 random() 函数返回的 long 转换为 Go 中的 int
```
下面的 2 个 Go 函数 Random() 和 Seed() 分别调用了 C 中的 C.random() 和 C.srandom()。

示例 3.2 c1.go
```golang
package rand

// #include <stdlib.h>
import "C"

func Random() int {
return int(C.random())
}

func Seed(i int) {
C.srandom(C.uint(i))
}
```
C 当中并没有明确的字符串类型，如果你想要将一个 string 类型的变量从 Go 转换到 C 时，可以使用 C.CString(s)；同样，可以使用 C.GoString(cs) 从 C 转换到 Go 中的 string 类型。

Go 的内存管理机制无法管理通过 C 代码分配的内存。

开发人员需要通过手动调用 C.free 来释放变量的内存：
```golang
defer C.free(unsafe.Pointer(Cvariable))
```
这一行最好紧跟在使用 C 代码创建某个变量之后，这样就不会忘记释放内存了。下面的代码展示了如何使用 cgo 创建变量、使用并释放其内存：

示例 3.3 c2.go
```golang
package print

// #include <stdio.h>
// #include <stdlib.h>
import "C"
import "unsafe"

func Print(s string) {
cs := C.CString(s)
defer C.free(unsafe.Pointer(cs))
C.fputs(cs, (*C.FILE)(C.stdout))
}
```