---
author: "wangjinbao"
title: "保证缓存和数据库的数据一致性"
date: 2022-05-18
description: "保证缓存和数据库的数据一致性"
draft: false
hideToc: false
enableToc: true
enableTocContent: false
author: wangjinbao
authorEmoji: 👻
tags:
- knowledge
categories:
- mysql
- redis
---

## 错误的解决方案
### 1 先更新数据库，再删除缓存
若数据库更新成功，删除缓存操作失败，则此后读到的都是缓存中过期的数据，造成不一致问题。

### 2 先更新数据库，再更新缓存
同删除缓存策略一样，若数据库更新成功缓存更新失败则会造成数据不一致问题。

### 3 先删除缓存，再更新数据库

| 时间 | 线程A    |  线程B   |  数据库   |  缓存   |
|--|-----|-----|-----|-----|
|1  | 删除缓存    |     | v1    |  null   |
| 2 |     |  缓存失效   |  v1   |   null  |
| 3 |     |  从数据库读取v1   |  v1   | null    |
| 4 |  更新数据库v2   |     |  v2   |  null   |
| 5 |     |  将v1写入缓存   |  v2   |  v1   |

### 4 先更新缓存，再更新数据库
若缓存更新成功数据库更新失败， 则此后读到的都是未持久化的数据。因为缓存中的数据是易失的，这种状态非常危险。
| 时间 | 线程A    |  线程B   |  数据库   |  缓存   |
|--|-----|-----|-----|-----|
|1  |     |     | v0    |  v0   |
| 2 |  更新缓存为v1   |     |  v0   |   v1  |
| 3 |     |  更新缓存为v2   |  v0   | v2    |
| 4 |     |  更新数据库为v2   |  v2   |  v2   |
| 5 |  更新数据库为v1   |     |  v1   |  v2   |


## 正确的解决方案

### 1 使用 CAS
CAS (Check-And-Set 或 Compare-And-Swap)是一种常见的保证并发安全的手段。CAS <font color='cyan'>**当且仅当客户端最后一次取值后该 key 没有被其他客户端修改的情况下，才允许当前客户端将新值写入**</font>。
```go
func CAS(oldVal, newVal) {
    if cache.get() == oldVal {
        cache.set(newVal)
    }
}
```

| 时间 | 线程A    |  线程B   |  数据库   |  缓存   |
|--|-----|-----|-----|-----|
|1  |     |     | v0    |  v0   |
| 2 |  更新数据库为v1   |     |  v1   |   v0  |
| 3 |     |  更新数据库为v2   |  v0   | v2    |
| 4 |     |  执行CAS操作：当且仅当缓存中为v0时将v2写入缓存   |  v2   |  v2   |
| 5 |  执行CAS操作：当且仅当缓存中为v0时将v1写入缓存。当前缓存为v2故放弃写缓存   |     |  v2   |  v2   |

+ 目前一些兼容 Redis 协议的中间件已经提供了 CAS 命令的支持，比如阿里的 Tair 以及腾讯的 Tendis。
+ Redis 官方本身是不支持CAS的操作,但是我们可以通过WATCH 和MULTI 命令实现类似的效果
+ <font color='cyan'>**WATCH 命令用于监视一个或多个键的变化，并在某个键被修改后取消事务，从而确保事务的原子性**</font>
+ <font color='cyan'>**MULTI 命令用于开始一个事务，将多个命令打包成一个事务，然后一次性执行。如果在执行事务期间有其他客户端对事务中的键进行修改，那么事务会被取消**</font>


### 2 使用分布式锁
CAS 假设发生并发问题的概率不大, 所以 CAS 也被称为乐观锁。那么悲观锁能否解决我们的问题呢？
还是以「先更新数据库，再更新缓存」方案中两个写线程竞争为例， 我们要求任何线程在写入或读取数据库 <font color='cyan'>**前都需要获取排它锁**</font> 。

| 时间 | 线程A    |  线程B   |  数据库   |  缓存   |
|--|-----|-----|-----|-----|
| 0  |     |     | v0    |  v0   |
|1  |  获取排它锁   |     | v0    |  v0   |
| 2 |  更新数据库为v1   |     |  v1   |   v0  |
| 3 |  更新缓存为v1  |     |  v1   | v1    |
| 4 |     |  等待排它锁   |  v1   |  v1   |
| 5 |  释放排它锁   |     |  v1   |  v1   |
| 6 |     |  获取排它锁   |  v1   |  v1   |
| 7 |     |  更新数据库为v2   |  v2   |  v1   |
| 8 |     |  更新缓存为v2   |  v2   |  v2   |
| 9 |     |  释放排它锁   |  v2   |  v2   |

分布式锁同样可以解决并发问题，只是成本可能略高。

### 3 使用消息队列异步更新

使用消息队列实现异步更新时，可以 <font color='cyan'>**将缓存更新的请求发送到消息队列中，由消息队列异步地处理缓存更新操作**</font>。

下面是一个简单的案例：
假设有一个电商网站，需要对商品信息进行缓存。当用户访问商品详情页面时，先从缓存中读取商品信息，如果缓存中没有，则从数据库中读取。

当商品信息发生变化时，需要更新缓存中的数据。这时可以通过消息队列异步更新缓存，具体步骤如下：
1. 当商品信息发生变化时，先更新数据库中的数据
2. 将商品信息更新请求发送到消息队列中
3. 消息队列异步地处理缓存更新操作，读取最新的商品信息，并将其更新到缓存中

这样就可以保证缓存中的数据是最新的，避免了因为缓存中的数据过期而导致的数据不一致问题。同时，使用消息队列可以提高更新的可靠性和性能，避免因为缓存更新失败而导致的数据库和缓存数据不一致问题。

>问题一：为什么异步更新可以解决?
> <font color='cyan'>**异步更新缓存：**</font>
> 当商品信息发生变化时，先更新数据库中的数据，然后将缓存更新请求发送到消息队列中，由消息队列异步地处理缓存更新操作。这样，即使缓存更新失败，也不会影响数据库中的数据，仅仅是缓存中的数据不是最新的而已。
> <font color='cyan'>**消息队列的可靠性：**</font>
> 消息队列通常具有高可靠性和高可用性，可以保证消息的可靠传输和处理。即使在消息队列出现故障的情况下，也可以通过消息队列的备份、重试等机制来保证消息的可靠性。因此，即使缓存更新失败，也可以通过重试等机制来保证缓存最终被更新。


----
>问题二：如果通过异步更新,更新缓存还是失败了怎么办?
> <font color='cyan'>**重试更新缓存：**</font>
> 当缓存更新失败时，可以尝试重新更新缓存。可以设置重试次数和重试间隔时间，避免因为频繁重试而影响性能。
> <font color='cyan'>**回滚数据库更新：**</font>
> 当缓存更新失败时，可以回滚数据库中的更新操作，保证数据库和缓存中的数据一致。但是，回滚操作可能会影响数据库中的其他操作，需要考虑到这个问题。
> <font color='cyan'>**延迟更新缓存：**</font>
> 当缓存更新失败时，可以将缓存更新请求放入一个延迟队列中，一段时间后再次尝试更新缓存。这样可以避免频繁重试而影响性能，同时保证缓存最终被更新。
> <font color='cyan'>**使用读写分离：**</font>
> 将读请求和写请求分别处理，读请求从缓存中读取数据，写请求先更新数据库，再更新缓存。这样可以避免因为缓存更新失败而导致的数据不一致问题。



### 3 数据库和缓存更新放在同一事务
可以保证在事务执行成功时，数据库和缓存中的数据都被更新；在事务执行失败时，数据库和缓存中的数据都不会被更新，保证了数据的一致性。

+ 要将 <font color='cyan'>**MySQL和Redis放入同一个事务中**</font>，需要使用 分布式事务处理框架，如 <font color='cyan'>**XA**</font> 或 <font color='cyan'>**TCC**</font>。这些框架可以确保在整个事务过程中，MySQL和Redis的操作都能够得到正确的协调和同步
+ XA：<font color='cyan'>**XA是一种分布式事务处理标准**</font>，它可以确保在多个数据库之间进行事务处理时，所有的操作都能够得到正确的协调和同步。在MySQL和Redis中都有XA实现，可以通过XA接口实现分布式事务。
+ TCC：TCC是一种补偿性事务处理框架，它通过 <font color='cyan'>**尝试（Try）、确认（Confirm）和取消（Cancel）**</font>三个步骤来实现分布式事务。在MySQL和Redis中都有TCC实现，可以通过TCC接口实现分布式事务
+ 需要注意的是，使用分布式事务框架会增加系统的复杂性和开销，需要仔细考虑是否真正需要在MySQL和Redis之间实现分布式事务如果可以接受稍微降低一些数据一致性的风险，可以使用其他技术来实现MySQL和Redis之间的数据同步，如 <font color='cyan'>**消息队列**</font>、<font color='cyan'>**定时任务**</font> 等。

