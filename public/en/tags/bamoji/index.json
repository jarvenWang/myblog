[{"content":"安装 Powerlevel9k 步骤一：安装 Powerline 字体库 1 2 3 4  $git clone https://github.com/powerline/fonts.git $./install.sh Copying fonts... Powerline fonts installed to /Users/wangdante/Library/Fonts （字段安装的目录）   brew tap 更新第三方库，才能用 homebrew 安裝字型。执行过可以跳过\nbrew tap caskroom/fonts (旧版本，新版本用：brew tap homebrew/cask)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 获取homebrew-cask-completion brew install brew-cask-completion # 获取homebrew-cask-fonts brew tap homebrew/cask-fonts # 获取homebrew-cask-drivers brew tap homebrew/cask-drivers # 查看满足nerd格式的字段有哪些，选择下载 brew search nerd ==\u0026gt; Formulae container-diff nerdctl ==\u0026gt; Casks font-go-mono-nerd-font font-sauce-code-pro-nerd-font ✔ ... # 下载/安裝指令 brew install homebrew/cask-fonts/font-sauce-code-pro-nerd-font   步骤二：安装 Powerlevel9k 主题 1 2 3 4 5 6 7 8 9 10 11 12  # 安装P9k $git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k # 配置 oh-my-zsh ：编辑 ~/.zshrc 修改zsh的主题 ZSH_THEME=\u0026#34;powerlevel9k/powerlevel9k\u0026#34; # 显示在左边的提示元素（分段位于括号中并以空格隔开） POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context # 显示在右边的提示元素（分段） POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status) # 左侧提示符是否显示两行（光标显示在下一行） POWERLEVEL9K_PROMPT_ON_NEWLINE=true   步骤三：修改终端字体： 修改终端所使用的字体为 你安装的某 nerd font 字体。 装完后，依次Preferences \u0026gt; Profiles \u0026gt; Text \u0026gt; Change Font，将字体改成SauceCodePro Nerd Font或你自己下载的字体：\n步骤四：source ~/.zshrc 使配置生效 步骤五：修改配色方案 1 2 3  git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git 之后import \u0026#39;Tomorrow Night Eighties\u0026#39; monokai remastered (个人比较喜欢)   配置好后，如下图：\n","description":"Powerlevel9k主题可以用于 vanilla ZSH 或 ZSH 框架，如 oh-my-ZSH、 Prezto、 Antigen 等等。","id":3,"section":"stack","tags":["linux",""],"title":"zsh下安装主题Powerlevel9k","uri":"http://ingress.test1.com/en/stack/linux/zsh/"},{"content":"一、4层代理和7层代理什么意思？ 这里的层是OSI 7层网络模型，OSI 模型是从上往下的，越底层越接近硬件，越往上越接近软件，这七层模型分别是：\n物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n  4层 是指传输层的 tcp / udp 。\n  7层 是指应用层，通常是http 。\n  二、代理原理 4层 用的是NAT技术。NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，请求进来的时候，nginx修改数据包里面的目标和源IP和端口，然后把数据包发向目标服务器，服务器处理完成后，nginx再做一次修改，返回给请求的客户端。\n7层代理：需要读取并解析http请求内容，然后根据具体内容(url,参数，cookie,请求头)然后转发到相应的服务器，转发的过程是：建立和目标机器的连接，然后转发请求，收到响应数据在转发给请求客户端。\n三、优缺点对比： 1、性能： 理论上4层要比7层快，因为7层代理需要解析数据包的具体内容，需要消耗额外的cpu。但nginx具体强大的网络并发处理能力， 对于一些慢连接，nginx可以先将网络请求数据缓冲完了一次性转发给上游server,这样对于上游网络并发处理能力弱的服务器(比如tomcat)，这样对tomcat来说就是慢连接变成快连接(nginx到tomcat基本上都是可靠内网),从而节省网络数据缓冲时间，提供并发性能。\n2、灵活性： 由于4层代理用的是NAT，所以nginx不知道请求的具体内容，所以nginx啥也干不了。 用7层代理，可以根据请求内容(url,参数，cookie,请求头)做很多事情，比如：\n  a:动态代理：不同的url转发到不同服务器。\n  b.风控：屏蔽外网IP请求某些敏感url；根据参数屏蔽某些刷单用户。\n  c.审计：在nginx层记录请求日志。\n  ","description":"Nginx负载均衡中4层代理和7层代理的区别","id":4,"section":"stack","tags":["linux",""],"title":"Nginx负载均衡中4层代理和7层代理的区别","uri":"http://ingress.test1.com/en/stack/linux/proxy47/"},{"content":"Machinery Golang的分布式任务队列还不算多，目前比较成熟的应该就只有 Machinery 了。\n如果熟悉Python中的异步任务框架的话，想必一定听过Celery。\n异步任务框架是什么呢？异步任务的主要作用是将需要长时间执行 的代码放到一个单独的程序中，例如调用第三方邮件接口，但是这个接口可能非常慢才响应，而你又想确保自己的API及时响应。这个 时候就可以采用异步任务来进行解耦。\n异步任务的组成和流程 一般来说，异步任务都由这么几部分组成：\n1 2 3 4  - broker：用来传递信息的，想象成“信使”，作用是暂时保存产生的任务以便于消费 - 生产者：它负责产生任务 - 消费者：它负责消费任务 - result backend：这个不是必需，但是如果有保存结果的需要，那么就需要它。   一般来流程：\n1 2 3  生产者发布任务 -\u0026gt; broker -\u0026gt; 消费者竞争任务，然后消费 -\u0026gt; (可选：消费后向broker确认已经消费，然后broker删除此任务，否则将超时重发任务) -\u0026gt; result backend保存结果   集成Machinery到goframe框架 步骤一 首先我们来把 Machinery 代码拉下来：\n1  $ go get github.com/RichardKnop/machinery/v2   在internal/cmd/cmd.go文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  var ( Main = gcmd.Command{ Func: func(ctx context.Context, parser *gcmd.Parser) (err error) { //获取命令参数并解析 \t//** goland中设置debug加参数(-server worker) \t//** 1、添加go build 执行脚本 \t//** 2、设置 Working directory:/Users/wangdante/D/kugou/go/src/tme_doc_api \t//** 3、Program arguments:-server worker) \t//-server worker \topt := gconv.Map(parser.GetOptAll()) server := opt[\u0026#34;server\u0026#34;] if server == \u0026#34;worker\u0026#34; { service.Machinery().Worker(ctx) return nil } else { s := g.Server() //------不需要鉴权------ \ts.Group(\u0026#34;/api\u0026#34;, func(group *ghttp.RouterGroup) { group.Middleware( ghttp.MiddlewareCORS, service.Middleware().MiddlewareLog, service.Middleware().MiddlewareErrorHandler, service.Middleware().MiddlewareResponseEcf, ) //绑定路由 \tgroup.Bind( controller.Hello, controller.Public, //controller.User, \t) }) //------需要鉴权------ \ts.Group(\u0026#34;/api\u0026#34;, func(group *ghttp.RouterGroup) { group.Middleware( ghttp.MiddlewareCORS, service.Middleware().MiddlewareLog, service.Middleware().MiddlewareErrorHandler, service.Middleware().MiddlewareResponseEcf, service.Middleware().MiddlewareToken, ) //gfToken.Middleware(ctx, group) \t//绑定路由 \tgroup.Bind( controller.User, ) }) s.Run() return nil } }, } )   步骤二 新建文件logic/machinery/machinery.go\n同时添加 jaeger.go 、 server.go 、 worker.go (来至拉下来的代码)\n在machinery文件中添加三个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166  func (s *sMachinery) Worker(ctx context.Context) error { consumerTag := \u0026#34;machinery_worker_ecf\u0026#34; cleanup, err := SetupTracer(consumerTag) if err != nil { log.FATAL.Fatalln(\u0026#34;Unable to instantiate a tracer:\u0026#34;, err) } defer cleanup() server, err := service.Machinery().StartServer() if err != nil { return err } // The second argument is a consumer tag \t// Ideally, each worker should have a unique tag (worker1, worker2 etc) \tworker := server.NewWorker(consumerTag, 0) // Here we inject some custom code for error handling, \t// start and end of task hooks, useful for metrics for example. \terrorHandler := func(err error) { log.ERROR.Println(\u0026#34;I am an error handler:\u0026#34;, err) } preTaskHandler := func(signature *tasks.Signature) { log.INFO.Println(\u0026#34;I am a start of task handler for:\u0026#34;, signature.Name) } postTaskHandler := func(signature *tasks.Signature) { log.INFO.Println(\u0026#34;I am an end of task handler for:\u0026#34;, signature.Name) } worker.SetPostTaskHandler(postTaskHandler) worker.SetErrorHandler(errorHandler) worker.SetPreTaskHandler(preTaskHandler) return worker.Launch() } func (s *sMachinery) Send(ctx context.Context) error { cleanup, err := SetupTracer(\u0026#34;sender\u0026#34;) if err != nil { log.FATAL.Fatalln(\u0026#34;Unable to instantiate a tracer:\u0026#34;, err) } defer cleanup() server, err := service.Machinery().StartServer() if err != nil { return err } var ( addTask0 tasks.Signature //addTask1, addTask2 tasks.Signature \t//multiplyTask0, multiplyTask1 tasks.Signature \t//sumIntsTask, sumFloatsTask, concatTask, splitTask tasks.Signature \t//panicTask tasks.Signature \t//longRunningTask tasks.Signature \t) var initTasks = func() { addTask0 = tasks.Signature{ Name: \u0026#34;add\u0026#34;, Args: []tasks.Arg{ { Type: \u0026#34;int64\u0026#34;, Value: 1, }, { Type: \u0026#34;int64\u0026#34;, Value: 1, }, }, } } /* * Lets start a span representing this run of the `send` command and * set a batch id as baggage so it can travel all the way into * the worker functions. */ span, ctx := opentracing.StartSpanFromContext(context.Background(), \u0026#34;send\u0026#34;) defer span.Finish() batchID := uuid.New().String() span.SetBaggageItem(\u0026#34;batch.id\u0026#34;, batchID) span.LogFields(opentracinglog.String(\u0026#34;batch.id\u0026#34;, batchID)) log.INFO.Println(\u0026#34;Starting batch:\u0026#34;, batchID) /* * First, let\u0026#39;s try sending a single task */ initTasks() log.INFO.Println(\u0026#34;Single task:\u0026#34;) asyncResult, err := server.SendTaskWithContext(ctx, \u0026amp;addTask0) if err != nil { return fmt.Errorf(\u0026#34;Could not send task: %s\u0026#34;, err.Error()) } results, err := asyncResult.Get(time.Millisecond * 5) if err != nil { return fmt.Errorf(\u0026#34;Getting task result failed with error: %s\u0026#34;, err.Error()) } log.INFO.Printf(\u0026#34;1 + 1 = %v\\n\u0026#34;, tasks.HumanReadableResults(results)) return nil } func (s *sMachinery) StartServer() (*machinery.Server, error) { //=====创建并配置broker=====  //读取redis配置参数 \tvar ctx = gctx.New() redisData, _ := g.Cfg().Get(ctx, \u0026#34;redis\u0026#34;) deMap := redisData.MapDeep()[\u0026#34;default\u0026#34;] var redisAddress, redisPass, redisQueue string var redisDB, redisExpire int if cnf, ok := deMap.(map[string]interface{}); ok { redisAddress = common.Strval(cnf[\u0026#34;address\u0026#34;]) redisPass = common.Strval(cnf[\u0026#34;pass\u0026#34;]) redisDB, _ = strconv.Atoi(common.Strval(cnf[\u0026#34;work\u0026#34;])) redisQueue = common.Strval(cnf[\u0026#34;default_queue\u0026#34;]) redisExpire, _ = strconv.Atoi(common.Strval(cnf[\u0026#34;expire_in\u0026#34;])) } cnf := \u0026amp;config.Config{ DefaultQueue: redisQueue, ResultsExpireIn: redisExpire, Redis: \u0026amp;config.RedisConfig{ MaxIdle: 3, IdleTimeout: 240, ReadTimeout: 15, WriteTimeout: 15, ConnectTimeout: 15, NormalTasksPollPeriod: 1000, DelayedTasksPollPeriod: 500, }, } // Create server instance \tbroker := redisbroker.New(cnf, redisAddress, redisPass, \u0026#34;\u0026#34;, redisDB) backend := redisbackend.New(cnf, redisAddress, redisPass, \u0026#34;\u0026#34;, redisDB) lock := eagerlock.New() server := machinery.NewServer(cnf, broker, backend, lock) //=====创建任务tasks=====  // Register tasks \ttasksMap := map[string]interface{}{ \u0026#34;add\u0026#34;: exampletasks.Add, // \u0026#34;multiply\u0026#34;: exampletasks.Multiply, \t//\u0026#34;sum_ints\u0026#34;: exampletasks.SumInts, \t// \u0026#34;sum_floats\u0026#34;: exampletasks.SumFloats, \t// \u0026#34;concat\u0026#34;: exampletasks.Concat, \t// \u0026#34;split\u0026#34;: exampletasks.Split, \t// \u0026#34;panic_task\u0026#34;: exampletasks.PanicTask, \t// \u0026#34;long_running_task\u0026#34;: exampletasks.LongRunningTask, \t} //=====注册任务tasks=====  return server, server.RegisterTasks(tasksMap) }   Machinery定时任务 步骤一：创建并配置broker 体能在方法StartServer中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  //=====创建并配置broker=====  //读取redis配置参数 var ctx = gctx.New() redisData, _ := g.Cfg().Get(ctx, \u0026#34;redis\u0026#34;) deMap := redisData.MapDeep()[\u0026#34;default\u0026#34;] var redisAddress, redisPass, redisQueue string var redisDB, redisExpire int if cnf, ok := deMap.(map[string]interface{}); ok { redisAddress = common.Strval(cnf[\u0026#34;address\u0026#34;]) redisPass = common.Strval(cnf[\u0026#34;pass\u0026#34;]) redisDB, _ = strconv.Atoi(common.Strval(cnf[\u0026#34;work\u0026#34;])) redisQueue = common.Strval(cnf[\u0026#34;default_queue\u0026#34;]) redisExpire, _ = strconv.Atoi(common.Strval(cnf[\u0026#34;expire_in\u0026#34;])) } cnf := \u0026amp;config.Config{ DefaultQueue: redisQueue, ResultsExpireIn: redisExpire, Redis: \u0026amp;config.RedisConfig{ MaxIdle: 3, IdleTimeout: 240, ReadTimeout: 15, WriteTimeout: 15, ConnectTimeout: 15, NormalTasksPollPeriod: 1000, DelayedTasksPollPeriod: 500, }, }   步骤二：创建server实例 1 2 3 4 5  // Create server instance broker := redisbroker.New(cnf, redisAddress, redisPass, \u0026#34;\u0026#34;, redisDB) backend := redisbackend.New(cnf, redisAddress, redisPass, \u0026#34;\u0026#34;, redisDB) lock := eagerlock.New() server := machinery.NewServer(cnf, broker, backend, lock)   步骤三：注册普通任务tasks 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //=====创建任务tasks=====  // Register tasks tasksMap := map[string]interface{}{ \u0026#34;add\u0026#34;: exampletasks.Add, \u0026#34;transferDepartment\u0026#34;: s.TransferDepartment, \u0026#34;transferBU\u0026#34;: s.TransferBU, \u0026#34;transferStaff\u0026#34;: s.TransferStaff, \u0026#34;ecfDepartment\u0026#34;: s.EcfDepartment, \u0026#34;ecfBU\u0026#34;: s.EcfBU, \u0026#34;ecfStaff\u0026#34;: s.EcfStaff, } return server, server.RegisterTasks(tasksMap)   步骤四：注册定时任务tasks 在注册完普通任务return注册定时任务即可\n公式：Cron * * * * ?: minute, hour, day of month, month and day of week\n1 2 3 4  signatureBU := \u0026amp;tasks.Signature{ Name: \u0026#34;transferBU\u0026#34;, } server.RegisterPeriodicTask(\u0026#34;57 9 * * ?\u0026#34;, \u0026#34;periodic-task-bu\u0026#34;, signatureBU)   步骤五：写好注册定时任务执行方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // TransferDepartment /** * @Name: TransferDepartment * @Description: 集团数据中转-行政组织 * @receiver s * @param args * @return int64 * @return error */ func (s *sMachinery) TransferDepartment(args ...int64) (int64, error) { ctx := context.TODO() service.Tme().GetCenterData(ctx, \u0026#34;department\u0026#34;) return 1, nil } // TransferBU /** * @Name: TransferBU * @Description: 集团数据中转-业务单元 * @receiver s * @param args * @return int64 * @return error */ func (s *sMachinery) TransferBU(args ...int64) (int64, error) { ctx := context.TODO() service.Tme().GetCenterData(ctx, \u0026#34;business_unit\u0026#34;) return 1, nil }   ","description":"goframe框架集成分布式异步任务队列machinery","id":5,"section":"stack","tags":["golang",""],"title":"goframe框架集成任务队列machinery和定时任务","uri":"http://ingress.test1.com/en/stack/golang/goframe_machinery/"},{"content":"命令管理 GetArg*参数获取  GetArg 方法用以获取默认解析的命令行参数，参数通过输入索引位置获取，索引位置从 0 开始，但往往我们需要获取的参数是从 1 开始，因为索引 0 的参数是程序名称。  1 2 3 4 5 6 7 8 9 10  func ExampleGetArg() { gcmd.Init(\u0026#34;gf\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;main.go\u0026#34;, \u0026#34;-o=gf.exe\u0026#34;, \u0026#34;-y\u0026#34;) fmt.Printf( `Arg[0]: \u0026#34;%v\u0026#34;, Arg[1]: \u0026#34;%v\u0026#34;, Arg[2]: \u0026#34;%v\u0026#34;, Arg[3]: \u0026#34;%v\u0026#34;`, gcmd.GetArg(0), gcmd.GetArg(1), gcmd.GetArg(2), gcmd.GetArg(3), ) // Output: \t// Arg[0]: \u0026#34;gf\u0026#34;, Arg[1]: \u0026#34;build\u0026#34;, Arg[2]: \u0026#34;main.go\u0026#34;, Arg[3]: \u0026#34;\u0026#34; }    GetArgAll 方法用于获取所有的命令行参数。  1 2 3 4 5 6 7  func ExampleGetArgAll() { gcmd.Init(\u0026#34;gf\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;main.go\u0026#34;, \u0026#34;-o=gf.exe\u0026#34;, \u0026#34;-y\u0026#34;) fmt.Printf(`%#v`, gcmd.GetArgAll()) // Output: \t// []string{\u0026#34;gf\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;main.go\u0026#34;} }   GetOpt*选项获取  GetOpt 方法用以获取默认解析的命令行选项，选项通过名称获取，并且选项的输入没有顺序性，可以输入到任意的命令行位置。当给定名称的选项数据不存在时，返回 nil。注意判断不带数据的选项是否存在时，可以通过 GetOpt(name) != nil 方式。  1 2 3 4 5 6 7 8 9 10  func ExampleGetOpt() { gcmd.Init(\u0026#34;gf\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;main.go\u0026#34;, \u0026#34;-o=gf.exe\u0026#34;, \u0026#34;-y\u0026#34;) fmt.Printf( `Opt[\u0026#34;o\u0026#34;]: \u0026#34;%v\u0026#34;, Opt[\u0026#34;y\u0026#34;]: \u0026#34;%v\u0026#34;, Opt[\u0026#34;d\u0026#34;]: \u0026#34;%v\u0026#34;`, gcmd.GetOpt(\u0026#34;o\u0026#34;), gcmd.GetOpt(\u0026#34;y\u0026#34;), gcmd.GetOpt(\u0026#34;d\u0026#34;, \u0026#34;default value\u0026#34;), ) // Output: \t// Opt[\u0026#34;o\u0026#34;]: \u0026#34;gf.exe\u0026#34;, Opt[\u0026#34;y\u0026#34;]: \u0026#34;\u0026#34;, Opt[\u0026#34;d\u0026#34;]: \u0026#34;default value\u0026#34; }    GetOptAll 方法用于获取所有的选项。  1 2 3 4 5 6 7  func ExampleGetOptAll() { gcmd.Init(\u0026#34;gf\u0026#34;, \u0026#34;build\u0026#34;, \u0026#34;main.go\u0026#34;, \u0026#34;-o=gf.exe\u0026#34;, \u0026#34;-y\u0026#34;) fmt.Printf(`%#v`, gcmd.GetOptAll()) // May Output: \t// map[string]string{\u0026#34;o\u0026#34;:\u0026#34;gf.exe\u0026#34;, \u0026#34;y\u0026#34;:\u0026#34;\u0026#34;} }   获取 命令后追加的选项参数，如 go build ecf -server worker\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //goframe框架中 opt := gconv.Map(parser.GetOptAll()) server := opt[\u0026#34;server\u0026#34;] if server == \u0026#34;worker\u0026#34; { service.Machinery().Worker(ctx) return nil } else { s := g.Server() //------不需要鉴权------ \ts.Group(\u0026#34;/api\u0026#34;, func(group *ghttp.RouterGroup) { ... }) //------需要鉴权------ \ts.Group(\u0026#34;/api\u0026#34;, func(group *ghttp.RouterGroup) { ... }) s.Run() return nil }   数据库结果处理 查询结果列表中添加字段 1 2 3 4 5 6 7 8 9 10 11  res, _ := model.All() gdbRes, ok := res.(gdb.Result) resList := gdbRes.List() if ok { for i, _ := range resList { //通过BU获取说明 \tsetid_desc := service.Common().GetBUDescByBU(resList[i][\u0026#34;setid\u0026#34;]) resList[i][\u0026#34;setid_desc\u0026#34;] = setid_desc ... } }   为空判断  数据集合  1 2 3 4 5 6 7 8  r, err := g.Model(\u0026#34;order\u0026#34;).Where(\u0026#34;status\u0026#34;, 1).All() if err != nil { return err } if len(r) == 0 { // 结果为空 }   也可以使用 IsEmpty 方法：\n1 2 3 4 5 6 7  r, err := g.Model(\u0026#34;order\u0026#34;).Where(\u0026#34;status\u0026#34;, 1).All() if err != nil { return err } if r.IsEmpty() { // 结果为空 }    数据记录  1 2 3 4 5 6 7  r, err := g.Model(\u0026#34;order\u0026#34;).Where(\u0026#34;status\u0026#34;, 1).One() if err != nil { return err } if len(r) == 0 { // 结果为空 }   也可以使用 IsEmpty 方法：\n1 2 3 4 5 6 7  r, err := g.Model(\u0026#34;order\u0026#34;).Where(\u0026#34;status\u0026#34;, 1).One() if err != nil { return err } if r.IsEmpty() { // 结果为空 }    数据字段值\n返回的是一个\u0026quot;泛型\u0026quot;变量，这个只能使用 IsEmpty 来判断是否为空了。  1 2 3 4 5 6 7  r, err := g.Model(\u0026#34;order\u0026#34;).Where(\u0026#34;status\u0026#34;, 1).Value() if err != nil { return err } if r.IsEmpty() { // 结果为空 }    字段值数组\n查询返回字段值数组本身类型为[]gdb.Value 类型，因此直接判断长度是否为 0 即可。  1 2 3 4 5 6 7 8  // Array/FindArray r, err := g.Model(\u0026#34;order\u0026#34;).Fields(\u0026#34;id\u0026#34;).Where(\u0026#34;status\u0026#34;, 1).Array() if err != nil { return err } if len(r) == 0 { // 结果为空 }   ORM 时区处理 设置loc=Local\n配置文件：\n1 2  database: link: \u0026#34;mysql:root:12345678@tcp(127.0.0.1:3306)/test?loc=Local\u0026#34;   示例代码：\n1 2 3 4  t1, _ := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2020-10-27 10:00:00\u0026#34;) t2, _ := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2020-10-27 11:00:00\u0026#34;) db.Model(\u0026#34;user\u0026#34;).Ctx(ctx).Where(\u0026#34;create_time\u0026gt;? and create_time\u0026lt;?\u0026#34;, t1, t2).One() // SELECT * FROM `user` WHERE create_time\u0026gt;\u0026#39;2020-10-27 18:00:00\u0026#39; AND create_time\u0026lt;\u0026#39;2020-10-27 19:00:00\u0026#39;   这里由于通过 time.Parse 创建的 time.Time 时间对象是 UTC 时区，那么提交到数据库执行时将会被底层的 driver 修改为+8 时区。\n1 2 3 4  t1, _ := time.ParseInLocation(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2020-10-27 10:00:00\u0026#34;, time.Local) t2, _ := time.ParseInLocation(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2020-10-27 11:00:00\u0026#34;, time.Local) db.Model(\u0026#34;user\u0026#34;).Ctx(ctx).Where(\u0026#34;create_time\u0026gt;? and create_time\u0026lt;?\u0026#34;, t1, t2).One() // SELECT * FROM `user` WHERE create_time\u0026gt;\u0026#39;2020-10-27 10:00:00\u0026#39; AND create_time\u0026lt;\u0026#39;2020-10-27 11:00:00\u0026#39;   这里由于通过 time.ParseInLocation 创建的 time.Time 时间对象是+8 时区，和 loc=Local 的时区一致，那么提交到数据库执行时不会被底层的 driver 修改。\ngen dao gf gen dao用于生成 model 数据结构定义文件\ngen model未来不再推荐这种方式，而是推荐使用 dao 的使用方式\ngoframe 中的 自动生成的 model 在dao文件夹下的internal文件夹下。\n不可以修改，Code generated by GoFrame CLI tool. DO NOT EDIT.\n所以自定义的 model 层在internal同级目录的.go 文件中编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package dao import ( \u0026#34;ecf/internal/dao/internal\u0026#34; \u0026#34;fmt\u0026#34; ) // internalUploadFileDao is internal type for wrapping internal DAO implements. type internalUploadFileDao = *internal.UploadFileDao // uploadFileDao is the data access object for table ecf_upload_file. // You can define custom methods on it to extend its functionality as you wish. type uploadFileDao struct { internalUploadFileDao } var ( // UploadFile is globally public accessible object for table ecf_upload_file operations. \t// UploadFile是全局公式的访问数据表对象 \tUploadFile = uploadFileDao{ internal.NewUploadFileDao(), } ) // Fill with you ideas below.  //todo //type SettingGetInput struct { //\tKey string //} func A() bool { ab := \u0026amp;internal.UploadFileDao{} UploadId := ab.Columns().UploadId fmt.Println(UploadId) // UploadFile是全局公式的访问数据表对象 \t// 获取指定字段 \tc := UploadFile.Columns().UploadId fmt.Println(c) return false }   ","description":"go语言起源、安装运行环境、编辑器、集成等","id":6,"section":"stack","tags":["golang",""],"title":"goframe框架-2","uri":"http://ingress.test1.com/en/stack/golang/goframe2/"},{"content":"手动编译安装 这是万能的安装方式：\n1  git clone https://github.com/gogf/gf \u0026amp;\u0026amp; cd gf/cmd/gf \u0026amp;\u0026amp; go install   验证安装成功 1 2 3 4 5  $ gf -v GoFrame CLI Tool v2.2.1, https://goframe.org GoFrame Version: cannot find goframe requirement in go.mod CLI Installed At: /usr/local/go/bin/gf Current is a custom installed version, no installation information.   创建项目模板 1  gf init demo -u   运行项目模板 项目模板可以执行以下命令运行：\n1  cd demo \u0026amp;\u0026amp; gf run main.go   会生成demo目录，里面就是个完整的项目\n把新项目独立出来 结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  ├── Makefile ├── README.MD ├── api │ └── v1 │ ├── hello.go │ └── user.go ├── go.mod ├── go.sum ├── hack │ └── config.yaml ├── internal │ ├── cmd │ │ └── cmd.go │ ├── consts │ │ └── consts.go │ ├── controller │ │ ├── hello.go │ │ └── user.go │ ├── dao │ │ ├── document.go │ │ └── internal │ │ └── document.go │ ├── logic │ │ └── middleware │ ├── model │ │ ├── do │ │ │ └── document.go │ │ └── entity │ │ └── document.go │ ├── packed │ │ └── packed.go │ └── service ├── main ├── main.go ├── manifest │ ├── config │ │ └── config.yaml │ ├── deploy │ │ └── kustomize │ │ ├── base │ │ │ ├── deployment.yaml │ │ │ ├── kustomization.yaml │ │ │ └── service.yaml │ │ └── overlays │ │ └── develop │ │ ├── configmap.yaml │ │ ├── deployment.yaml │ │ └── kustomization.yaml │ └── docker │ ├── Dockerfile │ └── docker.sh ├── resource │ ├── i18n │ ├── public │ │ ├── html │ │ ├── plugin │ │ └── resource │ │ ├── css │ │ ├── image │ │ └── js │ └── template └── utility   注册路由  查看internal/cmd/cmd.go，添加对象  1 2 3 4 5 6 7 8 9 10 11  ... s := g.Server() s.Group(\u0026#34;/api\u0026#34;, func(group *ghttp.RouterGroup) { group.Middleware(ghttp.MiddlewareHandlerResponse) group.Bind( controller.Hello, controller.User, ) }) s.Run() ...    添加控制器internal/controller/user.go  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package controller import ( \u0026#34;context\u0026#34; \u0026#34;github.com/gogf/gf/v2/frame/g\u0026#34; \u0026#34;ecf/api/v1\u0026#34; ) var ( User = cUser{} ) type cUser struct{} func (c *cUser) AuthLogin(ctx context.Context, req *v1.UserReq) (res *v1.UserRes, err error) { g.RequestFromCtx(ctx).Response.Writeln(\u0026#34;jarvenwang--AuthLogin\u0026#34;) return }    添加api/v1/user.go,添加 请求：UserReq，响应：UserRes  1 2 3 4 5 6 7 8 9  type UserReq struct { //path：路由地址  //method：post  //summary:概括  g.Meta `path:\u0026#34;/auth-login\u0026#34; tags:\u0026#34;AuthLogin\u0026#34; method:\u0026#34;post\u0026#34; summary:\u0026#34;登录\u0026#34;` } type UserRes struct { g.Meta `mime:\u0026#34;text/html\u0026#34; example:\u0026#34;string\u0026#34;` }   连接数据库  修改工具配置文件 ：hack/config.yaml  1 2 3 4 5 6 7 8 9 10 11  # CLI tool, only in development environment. # https://goframe.org/pages/viewpage.action?pageId=3673173 gfcli: gen: dao: - link: \u0026#34;mysql:root:654321@tcp(127.0.0.1:3306)/TME_ECF_DEV\u0026#34; tables: \u0026#34;ecf_document\u0026#34; removePrefix: \u0026#34;ecf_\u0026#34; jsonCase: \u0026#34;Snake\u0026#34; //指定model中生成的数据实体对象中json标签名称规则，参数不区分大小写  descriptionTag: true noModelComment: true   jsonCase 默认值 CamelLower\n   名称 必须 默认值 说明 示例     jsonCase  CamelLower 指定model中生成的数据实体对象中json标签名称规则，参数不区分大小写。参数可选为：Camel、CamelLower、Snake、SnakeScreaming、SnakeFirstUpper、Kebab、KebabScreaming。具体介绍请参考命名行帮助示例。 Snake：any_kind_of_string   removePrefix   删除数据表的指定前缀名称。多个前缀以,号分隔。 gf_   descriptionTag  false 用于指定是否为数据模型结构体属性增加desription的标签，内容为对应的数据表字段注释。 true   noModelComment  false 用于指定是否关闭数据模型结构体属性的注释自动生成，内容为数据表对应字段的注释。 true     执行命令 gf gen dao 生成数据对象  1 2 3 4 5  $gf gen dao generated: internal/dao/internal/document.go ... done!   数据库业务配置：\nmanifest/config/config.yaml\n1 2 3 4  database: default: link: \u0026#34;mysql:root:654321@tcp(127.0.0.1:3306)/TME_ECF_DEV\u0026#34; debug: true   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //控制器中添加 dao.Document.Ctx(ctx).Data(do.Document{ Setid: \u0026#34;TME01\u0026#34;, Deptid: \u0026#34;10000690\u0026#34;, Grade: 1, EcfName: \u0026#34;档案名称\u0026#34;, EcfCode: \u0026#34;ECFakfjdklfjdk\u0026#34;, Key1: \u0026#34;Key1\u0026#34;, Key2: \u0026#34;Key2\u0026#34;, Key3: \u0026#34;Key3\u0026#34;, FileCode: \u0026#34;FILEadflksajdlkf\u0026#34;, Class: \u0026#34;入职\u0026#34;, Style: \u0026#34;入职简历\u0026#34;, CreatedAt: time.Now().Unix(), }).Insert()   以上代码可能会报错，因为数据库驱动没有下载：\n安装mysql 驱动：\n1  go get -u github.com/gogf/gf/contrib/drivers/mysql/v2   区分环境配置文件 配置管理-文件配置 默认配置文件\n配置对象我们推荐使用单例方式获取，单例对象将会按照文件后缀toml/yaml/yml/json/ini/xml/properties文自动检索配置文件。默认情况下会自动检索配置文件config.toml/yaml/yml/json/ini/xml/properties并缓存，配置文件在外部被修改时将会自动刷新缓存。\n如果想要自定义文件格式，可以通过SetFileName方法修改默认读取的配置文件名称（如：default.yaml, default.json, default.xml等等）。例如，我们可以通过以下方式读取default.yaml配置文件中的数据库database配置项。\n1 2 3 4 5  // 设置默认配置文件，默认读取的配置文件设置为 default.yaml g.Cfg().GetAdapter().(*gcfg.AdapterFile).SetFileName(\u0026#34;default.yaml\u0026#34;) // 后续读取时将会读取到 default.yaml 配置文件内容 g.Cfg().Get(ctx, \u0026#34;database\u0026#34;)   文件可以是一个具体的文件名称或者完整的文件绝对路径。\n我们可以通过多种方式修改默认文件名称：\n 通过配置管理方法SetFileName修改。 修改命令行启动参数 - gf.gcfg.file。 修改指定的环境变量 - GF_GCFG_FILE。  假如我们的执行程序文件为main，那么可以通过以下方式修改配置管理器的配置文件目录(Linux下)：\n1 通过单例模式\n1  g.Cfg().GetAdapter().(*gcfg.AdapterFile).SetFileName(\u0026#34;default.yaml\u0026#34;)   2 通过命令行启动参数\n1  ./main --gf.gcfg.file=config.prod.toml   3 通过环境变量（常用在容器中）\n启动时修改环境变量：\n1  GF_GCFG_FILE=config.prod.toml; ./main   使用genv模块来修改环境变量：\n1  genv.Set(\u0026#34;GF_GCFG_FILE\u0026#34;, \u0026#34;config.prod.toml\u0026#34;)   实际操作：\n 步骤一：\n在manifest/config/目录下新增三个配置文件 ：\ndev.yaml\nuat.yaml\nprod.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14  dev.yaml文件内容： server: address: \u0026#34;:8002\u0026#34; openapiPath: \u0026#34;/api.json\u0026#34; swaggerPath: \u0026#34;/swagger\u0026#34; logger: level : \u0026#34;all\u0026#34; stdout: true database: default: link: \u0026#34;mysql:root:654321@tcp(127.0.0.1:3306)/TME_ECF_DEV\u0026#34; debug: true    步骤二：\n在main.go文件修改如下：  1 2 3 4 5 6 7 8 9  func main() { genv.Set(\u0026#34;env\u0026#34;, \u0026#34;dev\u0026#34;) //环境配置文件 \tenvfile := genv.Get(\u0026#34;env\u0026#34;).String() + \u0026#34;.yaml\u0026#34; //环境配置文件 \tg.Cfg().GetAdapter().(*gcfg.AdapterFile).SetFileName(envfile) cmd.Main.Run(gctx.New()) }   配置目录： 目录配置方法\ngcfg配置管理器支持非常灵活的多目录自动搜索功能，通过SetPath可以修改目录管理目录为唯一的目录地址，同时，我们推荐通过AddPath方法添加多个搜索目录，配置管理器底层将会按照添加目录的顺序作为优先级进行自动检索。直到检索到一个匹配的文件路径为止，如果在所有搜索目录下查找不到配置文件，那么会返回失败。\n默认目录配置\ngcfg配置管理对象初始化时，默认会自动添加以下配置文件搜索目录：\n当前工作目录及其下的config、manifest/config目录：例如当前的工作目录为/home/www时，将会添加：\na. /home/www\nb. /home/www/config\nc. /home/www/manifest/config\n当前可执行文件所在目录及其下的config、manifest/config目录：例如二进制文件所在目录为/tmp时，将会添加：\na. /tmp\nb. /tmp/config\nc. /tmp/manifest/config\n当前main源代码包所在目录及其下的config、manifest/config目录(仅对源码开发环境有效)：例如main包所在目录为/home/john/workspace/gf-app时，将会添加：\na. /home/john/workspace/gf-app\nb. /home/john/workspace/gf-app/config\nc. /home/john/workspace/gf-app/manifest/config\n默认目录修改\n注意这里修改的参数必须是一个目录，不能是文件路径。\n我们可以通过以下方式修改配置管理器的配置文件搜索目录，配置管理对象将会只在该指定目录执行配置文件检索：\n 通过配置管理器的SetPath方法手动修改； 修改命令行启动参数 - gf.gcfg.path； 修改指定的环境变量 - GF_GCFG_PATH；  假如我们的执行程序文件为main，那么可以通过以下方式修改配置管理器的配置文件目录(Linux下)：\n通过单例模式\n1  g.Cfg().GetAdapter().(*gcfg.AdapterFile).SetPath(\u0026#34;/opt/config\u0026#34;)   通过命令行启动参数\n1  ./main --gf.gcfg.path=/opt/config/   通过环境变量（常用在容器中）\n启动时修改环境变量：\n1  GF_GCFG_PATH=/opt/config/; ./main   使用genv模块来修改环境变量：\n1  genv.Set(\u0026#34;GF_GCFG_PATH\u0026#34;, \u0026#34;/opt/config\u0026#34;)   部署打包二进制执行文件 交叉编译-build 支持把配置文件打包到执行文件中\n编译配置文件：\nbuild支持同时从命令行以及配置文件指定编译参数、选项。GoFrame框架的所有组件及所有生态项目都是使用的同一个配置管理组件，默认的配置文件以及配置使用请参考章节 配置管理。以下是一个简单的配置示例供参考（以config.yaml为例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  gfcli: build: name: \u0026#34;gf\u0026#34; #当前系统架构，例如：386,amd64,arm arch: \u0026#34;all\u0026#34; system: \u0026#34;all\u0026#34; mod: \u0026#34;none\u0026#34; #可以不用，一般项目部署附带目录一起上传即可，不用打包到执行文件中，不方便修改配置参数 packSrc: \u0026#34;resource,manifest\u0026#34; version: \u0026#34;v1.0.0\u0026#34; output: \u0026#34;./bin\u0026#34; extra: \u0026#34;\u0026#34; #我本地的如下： build: name: \u0026#34;ecf\u0026#34; arch: \u0026#34;amd64\u0026#34; system: \u0026#34;linux\u0026#34; mod: \u0026#34;none\u0026#34; # packSrc: \u0026#34;resource,manifest\u0026#34; version: \u0026#34;v1.0.0\u0026#34; # output: \u0026#34;./bin\u0026#34; # extra: \u0026#34;\u0026#34;   日志配置 日志组件支持配置文件，当使用g.Log(单例名称)获取Logger单例对象时，将会自动通过默认的配置管理对象获取对应的Logger配置。默认情况下会读取logger.单例名称配置项，当该配置项不存在时，将会读取默认的logger配置项。配置项请参考配置对象结构定义：https://pkg.go.dev/github.com/gogf/gf/v2/os/glog#Config\n完整配置文件配置项及说明如下，其中配置项名称不区分大小写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  logger: path: \u0026#34;/var/log/\u0026#34; # 日志文件路径。默认为空，表示关闭，仅输出到终端 file: \u0026#34;{Y-m-d}.log\u0026#34; # 日志文件格式。默认为\u0026#34;{Y-m-d}.log\u0026#34; prefix: \u0026#34;\u0026#34; # 日志内容输出前缀。默认为空 level: \u0026#34;all\u0026#34; # 日志输出级别 ctxKeys: [] # 自定义Context上下文变量名称，自动打印Context的变量到日志中。默认为空 header: true # 是否打印日志的头信息。默认true stdout: true # 日志是否同时输出到终端。默认true rotateSize: 0 # 按照日志文件大小对文件进行滚动切分。默认为0，表示关闭滚动切分特性 rotateExpire: 0 # 按照日志文件时间间隔对文件滚动切分。默认为0，表示关闭滚动切分特性 rotateBackupLimit: 0 # 按照切分的文件数量清理切分文件，当滚动切分特性开启时有效。默认为0，表示不备份，切分则删除 rotateBackupExpire: 0 # 按照切分的文件有效期清理切分文件，当滚动切分特性开启时有效。默认为0，表示不备份，切分则删除 rotateBackupCompress: 0 # 滚动切分文件的压缩比（0-9）。默认为0，表示不压缩 rotateCheckInterval: \u0026#34;1h\u0026#34; # 滚动切分的时间检测间隔，一般不需要设置。默认为1小时 stdoutColorDisabled: false # 关闭终端的颜色打印。默认开启 writerColorEnable: false # 日志文件是否带上颜色。默认false，表示不带颜色   多个Logger的配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  logger: path: \u0026#34;/var/log\u0026#34; level: \u0026#34;all\u0026#34; stdout: false logger1: path: \u0026#34;/var/log/logger1\u0026#34; level: \u0026#34;dev\u0026#34; stdout: false logger2: path: \u0026#34;/var/log/logger2\u0026#34; level: \u0026#34;prod\u0026#34; stdout: true #我本地如下： server: address: \u0026#34;:8002\u0026#34; # openapiPath: \u0026#34;/api.json\u0026#34; # swaggerPath: \u0026#34;/swagger\u0026#34; logger: path: \u0026#34;./log/\u0026#34; file: \u0026#34;{Y-m-d}.log\u0026#34; level : \u0026#34;all\u0026#34; header: true stdout: false info: path: \u0026#34;./log/user/info/\u0026#34; file: \u0026#34;{Y-m-d}.log\u0026#34; level: \u0026#34;INFO\u0026#34; stdout: false error: path: \u0026#34;./log/user/error/\u0026#34; file: \u0026#34;{Y-m-d}.log\u0026#34; level: \u0026#34;ERRO\u0026#34; stdout: false   写入区分的目录类别日志：\n如下\n1 2 3 4 5 6 7 8  g.Log(\u0026#34;info\u0026#34;).Info(ctx, g.Map{\u0026#34;uid\u0026#34;: 1011110, \u0026#34;name\u0026#34;: \u0026#34;111john\u0026#34;}) type User struct { Uid int `json:\u0026#34;uid\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } g.Log(\u0026#34;error\u0026#34;).Error(ctx, User{100, \u0026#34;john\u0026#34;})   组件通用Handler\n组件提供了一些常用的日志Handler，方便开发者使用，提高开发效率。\nHandlerJson\n该Handler可以将日志内容转换为Json格式打印，方法名：\nglog.SetDefaultHandler(glog.HandlerJson)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/gogf/gf/v2/frame/g\u0026#34; \u0026#34;github.com/gogf/gf/v2/os/glog\u0026#34; ) func main() { ctx := context.TODO() #生成以json格式的日志 glog.SetDefaultHandler(glog.HandlerJson) g.Log().Debug(ctx, \u0026#34;Debugging...\u0026#34;) glog.Warning(ctx, \u0026#34;It is warning info\u0026#34;) glog.Error(ctx, \u0026#34;Error occurs, please have a check\u0026#34;) }   没有加载context的时候可以，用ctx := context.TODO()\n1  ctx := context.TODO()   自定义中间件 修改文件地址：internal/logic/middleware/middleware.go\n添加日志中间件： （前置中间件）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func (s *sMiddleware) MiddlewareLog(r *ghttp.Request) { //设置日志格式为json \tglog.SetDefaultHandler(glog.HandlerJson) rawQuery := r.URL.RawQuery host := r.URL.Host path := r.URL.Path method := r.Method clientIp := r.GetClientIp() //记录所有请求 \tctx := context.TODO() g.Log().Info(ctx, g.Map{\u0026#34;host\u0026#34;: host, \u0026#34;path\u0026#34;: path, \u0026#34;method\u0026#34;: method, \u0026#34;rawQuery\u0026#34;: rawQuery, \u0026#34;clientIp\u0026#34;: clientIp}) //前置中间件 \tr.Middleware.Next() }   添加报错处理中间件： (后置中间件)\n1 2 3 4 5 6 7 8 9 10 11  func (s *sMiddleware) MiddlewareErrorHandler(r *ghttp.Request) { r.Middleware.Next() if r.Response.Status \u0026gt;= http.StatusInternalServerError { r.Response.ClearBuffer() r.Response.WriteJson(ghttp.DefaultHandlerResponse{ Code: r.Response.Status, //请求成功 想改成200自己来 \tMessage: \u0026#34;服务器开小差了，请稍后再试\u0026#34;, Data: \u0026#34;\u0026#34;, }) } }   升级版本，捕获报错panic日志\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func (s *sMiddleware) MiddlewareErrorHandler(r *ghttp.Request) { r.Middleware.Next() if err := r.GetError(); err != nil { // 记录到自定义错误日志文件 //g.Log(\u0026#34;exception\u0026#34;).Error(err) ctx := context.TODO() g.Log(\u0026#34;panic\u0026#34;).Critical(ctx, err) r.Response.ClearBuffer() r.Response.WriteJson(ghttp.DefaultHandlerResponse{ Code: r.Response.Status, //请求成功 想改成200自己来 Message: \u0026#34;系统繁忙，请稍后再试\u0026#34;, Data: \u0026#34;\u0026#34;, }) } }   添加返回json格式中间件： （后置中间件）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  func (s *sMiddleware) MiddlewareResponseEcf(r *ghttp.Request) { r.Middleware.Next() //后置中间件 \tif r.Response.BufferLength() \u0026gt; 0 { return } //定义接受的相应结果及错误 \tvar ( msg string err = r.GetError() res = r.GetHandlerResponse() //s=r.params \t//code = gerror.Code(err) \t) //返回相应对象 及 获取不了的错误结果 \tif err != nil { code := gerror.Code(err) // 还没理解 后续补充 \tif code == gcode.CodeNil { code = gcode.CodeInternalError } r.Response.WriteJson(v1.DefaultHandlerResponse{ Code: http.StatusInternalServerError, //服务器内部错误 想改成500自己来 \tMsg: code.Message(), Data: nil, }) return } if ecfResponse, ok := res.(*v1.EcfRes); ok { //没有问题返回结果 \tr.Response.WriteJson(v1.DefaultHandlerResponse{ Code: ecfResponse.Code, //请求成功 想改成200自己来 \tMsg: ecfResponse.Msg, Data: ecfResponse.Data, }) } else { msg = \u0026#34;成功\u0026#34; //没有问题返回结果 \tr.Response.WriteJson(v1.DefaultHandlerResponse{ Code: http.StatusOK, //请求成功 想改成200自己来 \tMsg: msg, Data: res, }) } }    注意获取接口类型中的结构体字段的值，使用断言  1 2 3 4 5 6 7 8  if ecfResponse, ok := res.(*v1.EcfRes); ok { //没有问题返回结果 r.Response.WriteJson(v1.DefaultHandlerResponse{ Code: ecfResponse.Code, //请求成功 想改成200自己来 Msg: ecfResponse.Msg, Data: ecfResponse.Data, }) }   gtoken使用 一、下载gtoken\n1  go get github.com/goflyfox/gtoken   二、下载完包后整理依赖文件\n1  go mod tidy   三、在中间件包中添加login登录方法\n1 2 3 4 5 6 7 8 9 10 11 12  func AuthLogin(r *ghttp.Request) (string, interface{}) { username := r.GetPostString(\u0026#34;username\u0026#34;) passwd := r.GetPostString(\u0026#34;passwd\u0026#34;) // TODO 进行登录校验 \tif username == \u0026#34;\u0026#34; || passwd == \u0026#34;\u0026#34; { r.Response.WriteJson(gtoken.Fail(\u0026#34;账号或密码错误.\u0026#34;)) r.ExitAll() } return username, \u0026#34;\u0026#34; }   四、启动gtoken\n1 2 3 4 5 6  loginFunc := AuthLogin gfToken := \u0026amp;gtoken.GfToken{ LoginPath: \u0026#34;/auth-login\u0026#34;, //上面的方法地址,对应的是/api/auth-login \tLoginBeforeFunc: loginFunc, //只要固定类型方法：(r *ghttp.Request) (string, interface{}) \tLogoutPath: \u0026#34;/api/logout\u0026#34;, //暂时可以不写 }   五、postman请求接口，获取token\n 请求地址：/api/auth-login 输入账号/密码： 返回值如下：  1 2 3 4 5 6 7  { \u0026#34;code\u0026#34;: 0, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;token\u0026#34;: \u0026#34;F1om0nykaRN7gBi3u+Nr5RYYQSVCfkXjDGVz9lLaT+mnIoss6/knJ1uBT19A6QBW\u0026#34; } }   六、附带上面生成的token请求需鉴权接口\n 如请求地址：/api/info 选择Bearer Token，输入：F1om0nykaRN7gBi3u+Nr5RYYQSVCfkXjDGVz9lLaT+mnIoss6/knJ1uBT19A6QBW 返回如下：  1 2 3 4 5 6 7  { \u0026#34;code\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;成功\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;jarvenwang\u0026#34; } }   接口维护-gen service 设计背景 在业务项目实践中，业务逻辑封装往往是最复杂的部分，同时，业务模块之间的依赖十分复杂、边界模糊，无法采用Golang包管理的形式。如何有效管理项目中的业务逻辑封装部分，对于每个采用Golang开发的项目都是必定会遇到的难题。\n设计目标  增加logic分类目录，将所有业务逻辑代码迁移到logic分类目录下，采用包管理形式来管理业务模块。 业务模块之间的依赖通过接口化解耦，将原有的service分类调整为接口目录。这样每个业务模块将会各自维护、更加灵活 可以按照一定的项目规范，从logic业务逻辑代码生成service接口定义代码。同时，也允许人工维护这部分service接口。  命令使用(自动模式) 如果您是使用的GolandIDE，那么可以使用我们提供的配置文件：watchers.xml 自动监听代码文件修改时自动生成接口文件。使用方式，如下图：\nPreferences-\u0026gt;Tools-\u0026gt;File Watchers-\u0026gt;添加\u0026rsquo;Import\u0026rsquo;点击导入配置\n提供的配置文件：watchers.xml\n下载地址：https://goframe.org/download/attachments/49770772/watchers.xml?version=1\u0026amp;modificationDate=1655298456643\u0026amp;api=v2\n","description":"go语言起源、安装运行环境、编辑器、集成等","id":7,"section":"stack","tags":["golang",""],"title":"goframe框架-1","uri":"http://ingress.test1.com/en/stack/golang/goframe1/"},{"content":"一、工程目录结构 GoFrame业务项目基本目录结构如下（以Single Repo为例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  / ├── api ├── hack ├── internal │ ├── cmd │ ├── consts │ ├── controller │ ├── dao │ ├── logic │ ├── model │ | ├── do │ │ └── entity │ └── service ├── manifest ├── resource ├── utility ├── go.mod └── main.go      目录/文件名称 说明 描述     api 对外接口 对外提供服务的输入/输出数据结构定义。考虑到版本管理需要，往往以api/v1\u0026hellip;存在。   hack 工具脚本 存放项目开发工具、脚本等内容。例如，CLI工具的配置，各种shell/bat脚本等文件。   internal 内部逻辑 业务逻辑存放目录。通过Golang internal特性对外部隐藏可见性。   - cmd 入口指令 命令行管理目录。可以管理维护多个命令行。   - consts 常量定义 项目所有常量定义。   - controller 接口处理 接收/解析用户输入参数的入口/接口层。   - dao 数据访问 数据访问对象，这是一层抽象对象，用于和底层数据库交互，仅包含最基础的 CURD 方法   - logic 业务封装 业务逻辑封装管理，特定的业务逻辑实现和封装。往往是项目中最复杂的部分。   - model 结构模型 数据结构管理模块，管理数据实体对象，以及输入与输出数据结构定义。   - - do 领域对象 用于dao数据操作中业务模型与实例模型转换，由工具维护，用户不能修改。   - - entity 数据模型 数据模型是模型与数据集合的一对一关系，由工具维护，用户不能修改。   - service 业务接口 用于业务模块解耦的接口定义层。具体的接口实现在logic中进行注入。   manifest 交付清单 包含程序编译、部署、运行、配置的文件。常见内容如下：   - config 配置管理 配置文件存放目录。   - docker 镜像文件 Docker镜像相关依赖文件，脚本文件等等。   - deploy 部署文件 部署相关的文件。默认提供了Kubernetes集群化部署的Yaml模板，通过kustomize管理。   resource 静态资源 静态资源文件。这些文件往往可以通过 资源打包/镜像编译 的形式注入到发布文件中。   go.mod 依赖管理 使用Go Module包管理的依赖描述文件。   main.go 入口文件 程序入口文件。      对外接口\n对外接口包含两部分：接口定义（api）+接口实现（controller）。\n服务接口的职责类似于三层架构设计中的UI表示层，负责接收并响应客户端的输入与输出，包括对输入参数的过滤、转换、校验，对输出数据结构的维护，并调用 service 实现业务逻辑处理。\n  接口定义 - api\napi包用于与客户端约定的数据结构输入输出定义，往往与具体的业务场景强绑定。\n  接口实现 - controller\ncontroller用于接收api的输入，调用内部的一个或多个service包实现业务场景，组织service的结果构造为api的输出数据结构。\n  业务实现\n业务实现包含两部分：业务接口（service）+业务封装（logic）。\n  业务实现的职责类似于三层架构设计中的BLL业务逻辑层，负责具体业务逻辑的实现以及封装。\n  业务接口 - service\nservice包用于解耦业务模块之间的调用。业务模块之间往往不会直接调用对应的业务模块资源来实现业务逻辑，而是通过调用service接口。service层只有接口定义，具体的接口实现注入在各个业务模块中。\n  业务封装 - logic\nlogic包负责具体业务逻辑的实现以及封装。项目中各个层级代码不会直接调用logic层的业务模块，而是通过service接口层来调用。\n  结构模型\nmodel包的职责类似于三层架构中的Model模型定义层。模型定义代码层中仅包含全局公开的数据结构定义，往往不包含方法定义。\n  这里需要注意的是，这里的model不仅负责维护数据实体对象（entity）结构定义，也包括所有的输入/输出数据结构定义，被api/dao/service共同引用。这样做的好处除了可以统一管理公开的数据结构定义，也可以充分对同一业务领域的数据结构进行复用，减少代码冗余。\n  数据模型 - entity\n与数据集合绑定的程序数据结构定义，通常和数据表一一对应。\n  业务模型 - model\n与业务相关的通用数据结构定义，其中包含大部分的方法输入输出定义。\n  数据访问 - dao\ndao包的职责类似于三层架构中的DAL数据访问层，数据访问层负责所有的数据访问收口。\n  二、请求分层流转  cmd\ncmd层负责引导程序启动，显著的工作是初始化逻辑、注册路由对象、启动server监听、阻塞运行程序直至server退出。 api\n上层server服务接收客户端请求，转换为api中定义的Req接收对象、执行请求参数到Req对象属性的类型转换、执行Req对象中绑定的基础校验并转交Req请求对象给controller层。 controller\ncontroller层负责接收Req请求对象后做一些业务逻辑校验，随后调用一个或多个service实现业务逻辑，将执行结构封装为约定的Res数据结构对象返回。 model\nmodel层中管理了所有的业务模型，service资源的Input/Output输入输出数据结构都由model层来维护。 service\nservice是接口层，用于解耦业务模块，service没有具体的业务逻辑实现，具体的业务实现是依靠logic层注入的。 logic\nlogic层的业务逻辑需要通过调用dao来实现数据的操作，调用dao时需要传递do数据结构对象，用于传递查询条件、输入数据。dao执行完毕后通过Entity数据模型将数据结果返回给service层。 dao\ndao层通过框架的ORM抽象层组件与底层真实的数据库交互。\n  ","description":"go语言起源、安装运行环境、编辑器、集成等","id":8,"section":"stack","tags":["golang",""],"title":"goframe目录","uri":"http://ingress.test1.com/en/stack/golang/gofamedir/"},{"content":"一、基本结构与基本数据类型 1、文件名、关键字与标识符 1.1 文件名  文件名 均由小写字母组成，如 scanner.go。 如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 scanner_test.go 文件名不包含 空格 或 其他特殊字符。  _ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个这个标识符作为变量对其它变量的进行赋值或运算。\n1.2 关键字 Go 代码中会使用到的 25 个关键字或保留字：\n           break default func interface   case defer go map   chan else goto package   const fallthrough if range   continue for import return    1.3 标识符 Go 语言还有 36 个预定义标识符:\n             append bool byte cap close complex   copy false float32 float64 imag int   int32 int64 iota len make new   print println real recover string true    程序一般由关键字、常量、变量、运算符、类型和函数组成。\n程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。\n程序中可能会使用到这些标点符号：.、,、;、: 和 …。\n程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号 ;\n结尾，因为这些工作都将由 Go 编译器自动完成。\n如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。\n2、Go 程序的基本结构和要素 2.1 包的概念、导入与可见性 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。\n一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。\n标准库:\n在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。\n一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。\n如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。\nGo 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。\n如果 A.go 依赖 B.go，而 B.go 又依赖 C.go：\n编译 C.go, B.go, 然后是 A.go.\n为了编译 A.go, 编译器读取的是 B.o 而不是 C.o.\n这种机制对于编译大型的项目时可以显著地提升编译速度。\n每一段代码只会被编译一次\n如果需要多个包，它们可以被分别导入：\n更短且更优雅的方法（被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义）：\n1 2 3 4  import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; )    如果包名不是以 . 或 / 开头，如 \u0026ldquo;fmt\u0026rdquo; 或者 \u0026ldquo;container/list\u0026rdquo;，则 Go 会在 全局文件 进行查找； 如果包名以 ./ 开头，则 Go 会在 相对目录 中查找； 如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。  可见性规则:\n 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）； 标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。  包的分级声明和初始化:\n可以在使用 import 导入包之后定义或声明 0 个或多个常量（const）、变量（var）和类型（type），这些对象的 作用域 都是全局的（在本包范围内），所以可以被本包中所有的函数调用 ,然后声明一个或多个函数（func）\n2.2 函数 这是定义一个函数最简单的格式：\nfunc functionName()\n函数里的代码（函数体）使用大括号 {} 括起来。\n左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示：\nbuild-error: syntax error: unexpected semicolon or newline before {\nGo 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误\n2.3 注释 package main\nimport \u0026ldquo;fmt\u0026rdquo; // Package implementing formatted I/O.\nfunc main() {\nfmt.Printf(\u0026ldquo;Καλημέρα κόσμε; or こんにちは 世界\\n\u0026rdquo;)\n}\n\n上面这个例子通过打印 Καλημέρα κόσμε; or こんにちは 世界 展示了如何在 Go 中使用国际化字符，以及如何使用注释。\n 单行注释是最常见的注释形式，你可以在任何地方使用以  //  开头的单行注释。 多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。  2.4 类型 可以包含数据的变量（或常量）可以使用不同的数据类型或类型来保存数据。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。\n   基本类型     int   float   bool   string       复合类型     struct   array   slice   map   channel       描述类型     interface    Go 语言中不存在类型继承\n2.5 Go 程序的一般结构 Go 程序的执行（程序启动）顺序如下：\n 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。  2.6 类型转换 在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：\nvalueOfTypeB = typeB(valueOfTypeA)\n类型 B 的值 = 类型 B(类型 A 的值)\n1 2  a := 5.0 b := int(a)   但这只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（例如将 int16 转换为 int32）。当从一个取值范围较大的转换到取值范围较小的类型时（例如将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。\n具有相同底层类型的变量之间可以相互转换：\n1 2 3  var a IZ = 5 c := int(a) d := IZ(c)   3、常量 常量使用关键字 const 定义，用于存储 不会改变 的数据。\n如：\n1 2 3 4 5  const Pi = 3.14159 显式类型定义： const b string = \u0026#34;abc\u0026#34; 隐式类型定义： const b = \u0026#34;abc\u0026#34;   常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。\n1 2 3  正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value   因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。\n在这个例子中，iota 可以被用作枚举值：\n1 2 3 4 5  const ( a = iota b = iota c = iota )   第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：\n1 2 3 4 5  const ( a = iota b c )   简单地讲，每遇到一次 const 关键字，iota 就重置为 0\n4、变量 这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。\n示例：\n1 2 3  var a int var b bool var str string   你也可以改写成这种形式：\n1 2 3 4 5  var ( a int b bool str string )   5、基本类型和运算符 6、字符串 7、strings 和 strconv 包 8、时间和日期 9、指针 ","description":"go语言起源、安装运行环境、编辑器、集成等","id":9,"section":"stack","tags":["golang",""],"title":"学习go(第二部分)","uri":"http://ingress.test1.com/en/stack/golang/go_part2/"},{"content":"一、起源与发展 起源 Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：\n Robert Griesemer（参与开发 Java HotSpot 虚拟机） Rob Pike（Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言） Ken Thompson（贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范）  时间轴：  2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言  为什么要创造一门编程语言  C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。 对比计算机性能的提升，软件开发领域不被认为发展地足够快或者比硬件发展更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。  Go 语言的发展目标 Go 语言的主要目标 ：\n将 静态语言的 安全性 和 高效性  与 动态语言的 易开发性 进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。\n因此，Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。\nGo 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机，这一点对于谷歌内部的使用来说就非常重要了。设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。\n这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。\nGo 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。这不仅极大地提升了开发者的生产力，同时也使得软件开发过程中的代码测试环节更加紧凑，而不必浪费大量的时间在等待程序的构建上。\n依赖管理  是现今软件开发的一个重要组成部分，但是 C 语言中“头文件”的概念却导致越来越多因为依赖关系而使得构建一个大型的项目需要长达几个小时的时间。人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。\n整个 Go 语言标准库的编译时间一般都在 20 秒以内，其它的常规项目也只需要半秒钟的时间来完成编译工作。这种闪电般的编译速度甚至比编译 C 语言或者 Fortran 更加快，使得编译这一环节不再成为在软件开发中困扰开发人员的问题。在这之前，动态语言将快速编译作为自身的一大亮点，像 C++ 那样的静态语言一般都有非常漫长的编译和链接工作。而同样作为静态语言的 Go 语言，通过自身优良的构建机制，成功地了去除了这个弊端，使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。\n另外，Go 语言在执行速度方面也可以与 C/C++ 相提并论。\n由于内存问题（通常称为内存泄漏）长期以来一直伴随着 C++ 的开发者们，Go 语言的设计者们认为内存管理不应该是开发人员所需要考虑的问题。因此尽管 Go 语言像其它静态语言一样执行本地代码，但它依旧运行在某种意义上的虚拟机，以此来实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。\n尽管垃圾回收并不容易实现，但考虑这将是未来并发应用程序发展的一个重要组成部分，Go 语言的设计者们还是完成了这项艰难的任务。\nGo 语言还能够在运行时进行反射相关的操作。\n使用 go install 能够很轻松地对第三方包进行部署。\n此外，Go 语言还支持调用由 C 语言编写的海量库文件（第 3.9 节），从而能够将过去开发的软件进行快速迁移。\n关于特性缺失 许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。\n 为了简化设计，不支持函数重载和操作符重载 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换 Go 语言通过另一种途径实现面向对象设计来放弃类和类型的继承 尽管在接口的使用方面可以实现类似变体类型的功能，但本身不支持变体类型 不支持动态加载代码 不支持动态链接库 不支持泛型 通过 recover 和 panic 来替代异常机制 不支持断言 不支持静态变量  必杀技  简化问题，易于学习 内存管理，简洁语法，易于使用 快速编译，高效开发 高效执行 并发支持，轻松驾驭 静态类型 标准类库，规范统一 易于部署 文档全面 免费开源  二、安装与运行环境 Go 语言开发团队开发了适用于以下操作系统的编译器：\n Linux FreeBSD Mac OS X（也称为 Darwin）  目前有2个版本的编译器：Go 原生编译器 gc 和 非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。其中，gc 版本的编译器已经被移植到 Windows 平台上，并集成在主要发行版中，你也可以通过安装 MinGW 从而在 Windows 平台下使用 gcc 编译器。这两个编译器都是以单通道的形式工作。\n你可以获取以下平台上的 Go 1.4 源码和二进制文件：\n Linux 2.6+：amd64、386 和 arm 架构 Mac OS X（Snow Leopard + Lion）：amd64 和 386 架构 Windows 2000+：amd64 和 386 架构  1、Go 原生编译器 gc： 主要基于 Ken Thompson 先前在 Plan 9 操作系统上使用的 C 工具链。\nGo 语言的编译器和链接器都是使用 C 语言编写并产生本地代码，Go 不存在自我引导之类的功能。因此如果使用一个有不同指令集的编译器来构建 Go 程序，就需要针对操作系统和处理器架构（32 位操作系统或 64 位操作系统）进行区别对待。\n这款编译器使用非分代、无压缩和并行的方式进行编译，它的编译速度要比 gccgo 更快，产生更好的本地代码，但编译后的程序不能够使用 gcc 进行链接。\n2、gccgo 编译器： 一款相对于 gc 而言更加传统的编译器，使用 GCC 作为后端。GCC 是一款非常流行的 GNU 编译器，它能够构建基于众多处理器架构的应用程序。编译速度相对 gc 较慢，但产生的本地代码运行要稍微快一点。它同时也提供一些与 C 语言之间的互操作性。\n从 Go 1 版本开始，gc 和 gccgo 在编译方面都有等价的功能。\n3、Go 环境变量 Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之间就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：\n $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm(苹果M1 芯片)。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。  Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。\n为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置目标机器的参数，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。\n $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节  4、linux安装 传送门：/en/stack/golang/install_linux/\n5、mac安装 传送门：/en/stack/golang/get_started/\n6、调试器 1、dlv\n1  dlv debug --headless --listen=:2345 --log --api-version 2   2、在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息：\n %+v 打印包括字段在内的实例的完整信息\n+%#v 打印包括字段和限定类型名称在内的实例的完整信息 %T 打印某个类型的完整说明  3、panic 语句\n4、关键字 defer 来跟踪代码执行过程\n7、构建并运行 Go 程序 从 Go 1 版本开始，使用 Go 自带的更加方便的工具来构建应用程序：\n go build 编译并安装自身包和依赖包 go install 安装自身包和依赖包  Go语言是 编译型 的 静态语言（和C语言一样），所以在运行Go语言程序之前，先要将其编译成二进制的可执行文件。\ngo build: 可以将Go语言程序代码编译成二进制的可执行文件，但是需要我们手动运行该二进制文件；\ngo build 命令用来启动编译，它可以将Go语言程序与相关依赖编译成一个可执行文件，其语法格式如下。\ngo build fileName 其中 fileName 为所需要的参数，可以是一个或者多个 Go 源文件名（当有多个参数时需要使用空格将两个相邻的参数隔开），也可以省略不写。\n使用 go build 命令进行编译时，不同参数的执行结果也是不同的。\n如编译打包linux 生产环境 的包：\n1  GOOS=linux GOARCH=amd64 GIN_MODE=release go build main.go    当参数不为空时如果 fileName 为同一 main 包下的所有源文件名（可能有一个或者多个），编译器将生成一个与第一个 fileName 同名的可执行文件（如执行\ngo build abc.go def.go \u0026hellip;会生成一个 abc.exe 文件）；如果 fileName 为非 main 包下的源文件名，编译器将只对该包进行语法检查，不生成可执行文件。 当参数为空时如果当前目录下存在 main 包，则会生成一个与当前目录名同名的“目录名.exe”可执行文件（如在 hello 目录中执行 go build命令时，会生成 hello.exe 文件）；如果不存在 main 包，则只对当前目录下的程序源码进行语法检查，不会生成可执行文件。  go run 更加方便，它会在编译后直接运行Go语言程序，编译过程中会产生一个临时文件，但不会生成可执行文件，这个特点很适合用来调试程序。\ngo run命令将编译和执行指令合二为一，会在编译之后立即执行Go语言程序，但是不会生成可执行文件。\ngo run命令的语法格式如下：\n1  go run fileName   其中 fileName 为所需要的参数，参数必须是同一 main 包下的所有源文件名，并且不能为空。\n8、其它工具 Go 自带的工具集主要使用脚本和 Go 语言自身编写的，目前版本的 Go 实现了以下三个工具：\n go install 是安装 Go 包的工具，类似 Ruby 中的 rubygems。主要用于安装非标准库的包文件，将源代码编译成对象文件。 go fix 用于将你的 Go 代码从旧的发行版迁移到最新的发行版，它主要负责简单的、重复的、枯燥无味的修改工作，如果像 API 等复杂的函数修改，工具则会给出文件名和代码行数的提示以便让开发人员快速定位并升级代码。Go 开发团队一般也使用这个工具升级 Go 内置工具以及 谷歌内部项目的代码。go fix 之所以能够正常工作是因为 Go 在标准库就提供生成抽象语法树和通过抽象语法树对代码进行还原的功能。该工具会尝试更新当前目录下的所有 Go 源文件，并在完成代码更新后在控制台输出相关的文件名称。 go test 是一个轻量级的单元测试框架  9、与 C 进行交互 工具 cgo 提供了对 FFI（外部函数接口）的支持，能够使用 Go 代码安全地调用 C 语言库，你可以访问 cgo 文档主页：http://golang.org/cmd/cgo。cgo 会替代 Go 编译器来产生可以组合在同一个包中的 Go 和 C 代码。在实际开发中一般使用 cgo 创建单独的 C 代码包。\n如果你想要在你的 Go 程序中使用 cgo，则必须在单独的一行使用 import \u0026ldquo;C\u0026rdquo; 来导入，一般来说你可能还需要 import \u0026ldquo;unsafe\u0026rdquo;。\n然后，你可以在 import \u0026ldquo;C\u0026rdquo; 之前使用注释（单行或多行注释均可）的形式导入 C 语言库（甚至有效的 C 语言代码），它们之间没有空行，例如：\n1 2 3  // #include \u0026lt;stdio.h\u0026gt; // #include \u0026lt;stdlib.h\u0026gt; import \u0026#34;C\u0026#34;   名称 \u0026ldquo;C\u0026rdquo; 并不属于标准库的一部分，这只是 cgo 集成的一个特殊名称用于引用 C 的命名空间。在这个命名空间里所包含的 C 类型都可以被使用，例如 C.uint、C.long 等等，还有 libc 中的函数 C.random() 等也可以被调用。\n当你想要使用某个类型作为 C 中函数的参数时，必须将其转换为 C 中的类型，反之亦然，例如：\n1 2 3  var i int C.uint(i) // 从 Go 中的 int 转换为 C 中的无符号 int int(C.random()) // 从 C 中 random() 函数返回的 long 转换为 Go 中的 int   下面的 2 个 Go 函数 Random() 和 Seed() 分别调用了 C 中的 C.random() 和 C.srandom()。\n示例 3.2 c1.go\n1 2 3 4 5 6 7 8 9 10 11 12  package rand // #include \u0026lt;stdlib.h\u0026gt; import \u0026#34;C\u0026#34; func Random() int { return int(C.random()) } func Seed(i int) { C.srandom(C.uint(i)) }   C 当中并没有明确的字符串类型，如果你想要将一个 string 类型的变量从 Go 转换到 C 时，可以使用 C.CString(s)；同样，可以使用 C.GoString(cs) 从 C 转换到 Go 中的 string 类型。\nGo 的内存管理机制无法管理通过 C 代码分配的内存。\n开发人员需要通过手动调用 C.free 来释放变量的内存：\n1  defer C.free(unsafe.Pointer(Cvariable))   这一行最好紧跟在使用 C 代码创建某个变量之后，这样就不会忘记释放内存了。下面的代码展示了如何使用 cgo 创建变量、使用并释放其内存：\n示例 3.3 c2.go\n1 2 3 4 5 6 7 8 9 10 11 12  package print // #include \u0026lt;stdio.h\u0026gt; // #include \u0026lt;stdlib.h\u0026gt; import \u0026#34;C\u0026#34; import \u0026#34;unsafe\u0026#34; func Print(s string) { cs := C.CString(s) defer C.free(unsafe.Pointer(cs)) C.fputs(cs, (*C.FILE)(C.stdout)) }   ","description":"go语言起源、安装运行环境、编辑器、集成等","id":10,"section":"stack","tags":["golang",""],"title":"学习go(第一部分)","uri":"http://ingress.test1.com/en/stack/golang/go_part1/"},{"content":"一、下载 去官网下载 ，国内地址：https://golang.google.cn/dl/\n1  $ wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz   二、解压(需要root权限) 1  $ sudo tar -C /usr/local -xzf go1.16.7.linux-amd64.tar.gz   三、项目目录 1  $ mkdir -p /home/go/src /home/go/pkg /home/go/bin   四、环境变量 1 2 3 4 5 6 7 8 9 10  vi /etc/profile shift + g 可以跳转到最后一行 然后按a,回车到新的一行 export GOROOT=/usr/local/go export GOPATH=/home/gopath export PATH=$PATH:$GOROOT/bin:$GOPATH/bin 然后按ESC,输入 :wq source /etc/profile   五、校验环境 1  $ go env   六、测试程序 1 2  $ cd /home/go/src $ vi main.go   1 2 3 4 5 6  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) }   然后按ESC,输入 :wq\n1  go run ./main.go   ","description":"整理在mac上的golang安装、配置及版本升级","id":11,"section":"stack","tags":["golang",""],"title":"linux安装golang","uri":"http://ingress.test1.com/en/stack/golang/install_linux/"},{"content":"1、左大括号 { 不能单独放一行 在其他大多数语言中，{ 的位置你自行决定。Go比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加;来分隔多条语句，比如会在 ) 后加分号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 错误示例 func main() { println(\u0026#34;hello world\u0026#34;) } // 等效于 func main(); // 无函数体 { println(\u0026#34;hello world\u0026#34;) } ./main.go: missing function body ./main.go: syntax error: unexpected semicolon or newline before { // 正确示例 func main() { println(\u0026#34;hello world\u0026#34;) }   2、未使用的变量 如果在函数体代码中有未使用的变量，则无法通过编译，不过 全局变量 声明但不使用是\n可以的。即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 错误示例 var gvar int // 全局变量，声明不使用也可以  func main() { var one int // error: one declared and not used  two := 2 // error: two declared and not used  var three int // error: three declared and not used  three = 3 } // 正确示例 // 可以直接注释或移除未使用的变量 func main() { var one int _ = one two := 2 println(two) var three int one = three var four int four = four }   3、未使用的 import 如果你 import一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。可以使用_下划线符号作为别\n名来忽略导入的包，从而避免编译错误，这只会执行 package 的 init()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 错误示例 import ( \u0026#34;fmt\u0026#34; // imported and not used: \u0026#34;fmt\u0026#34;  \u0026#34;log\u0026#34; // imported and not used: \u0026#34;log\u0026#34;  \u0026#34;time\u0026#34; // imported and not used: \u0026#34;time\u0026#34; ) func main() { } // 正确示例 // 可以使用 goimports 工具来注释或移除未使用到的包 import ( _ \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; ) func main() { _ = log.Println _ = time.Now }   4、获取命令⾏参数 与其他主要编程语⾔的差异\n main 函数不⽀持传⼊参数func main(arg []string ) 在程序中直接通过 os.Args 获取命令⾏参数  5、编写测试程序  源码⽂件以 _test 结尾：xxx_test.go 测试⽅法名以 Test 开头：func TestXXX(t *testing.T) {…}  6、变量赋值  赋值可以进⾏⾃动类型推断 在⼀个赋值语句中可以对多个变量进⾏同时赋值  基本数据类型:\n类型\n1 bool\n2 string\n3 int int8 int16 int32 int64\n4 uint uint8 uint16 uint32 uint64 uintptr\n5 byte // alias for uint8\n6 rune // alias for int32,represents a Unicode code point\n7 float32 float64\n8 complex64 complex128\n7、⽤ == 比较数组  相同维数且含有相同个数元素的数组才可以⽐较 每个元素都相同的才相等  8、简短声明的变量只能在函数内部使用 1 2 3 4 5 6 7 8 9 10  // 错误示例 myvar := 1 // syntax error: non-declaration statement outside function body func main() { } // 正确示例 var myvar = 1 func main() { }   9、使用简短声明来重复声明变量 不能用简短声明方式来单独为一个变量重复声明，:=左侧至少有一个新变量，才允许多变量的重复声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 错误示例 func main() { one := 0 one := 1 // error: no new variables on left side of := } // 正确示例 func main() { one := 0 one, two := 1, 2 // two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err  one, two = two, one // 交换两个变量值的简写 }   10、map遍历是顺序不固定 map是一种hash表实现，每次遍历的顺序都可能不一样。\nGo 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的\n1 2 3 4 5 6 7 8 9 10 11 12  func main() { m := map[string]string{ \u0026#34;1\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;: \u0026#34;3\u0026#34;, } for k, v := range m { println(k, v) } }   11、自增和自减运算 很多编程语言都自带前置后置的 ++、– 运算。但 Go 特立独行，去掉了前置操作，同时 ++、— 只作为运算符而非表达式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 错误示例 func main() { data := []int{1, 2, 3} i := 0 ++i // syntax error: unexpected ++, expecting }  fmt.Println(data[i++]) // syntax error: unexpected ++, expecting : } // 正确示例 func main() { data := []int{1, 2, 3} i := 0 i++ fmt.Println(data[i]) // 2 }   12、运算符的优先级 除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。\n优先级列表：\n   Precedence Operator     5 * / % \u0026laquo; \u0026raquo; \u0026amp; \u0026amp;^   4 + -   3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;=   2 \u0026amp;\u0026amp;   1 2个竖线    13、new() 与 make() 的区别 new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。\nnew(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。\nmake(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.\n14、gin-从中间件将参数传递给路由控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { c.Set(\u0026#34;request\u0026#34;, \u0026#34;test_request\u0026#34;) } } router.Use(MiddleWare()){ router.GET(\u0026#34;/middleware\u0026#34;, func(c *gin.Context) { // 两种方式都可以获取  request := c.MustGet(\u0026#34;request\u0026#34;).(string) request2, _ := c.Get(\u0026#34;request\u0026#34;) c.JSON(http.StatusOK, gin.H{ \u0026#34;request\u0026#34;: request, \u0026#34;request2\u0026#34;: request2, }) }) }   ","description":"golang开发中的一些小注意点整理","id":12,"section":"stack","tags":["golang",""],"title":"golang注意事项","uri":"http://ingress.test1.com/en/stack/golang/tips/"},{"content":"一、下载 去官网下载 ，国内地址：https://golang.google.cn/dl/\n选择对应的版本即可，我本地使用的是https://golang.google.cn/dl/go1.18.3.darwin-arm64.pkg\n二、安装及设置环境变量 修改文件：\n/etc/profile\n1 2 3 4 5 6 7 8 9  $ sudo vim /etc/profile # 在文件尾部加上： #golang export GOROOT=/usr/local/go export GOPATH=/Users/wangdante/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN # 使生效 $ source /etc/profile   我使用zsh，所以也修改~/.zshrc\n1 2 3 4 5 6 7 8  vim ~/.zshrc #golang export GOROOT=/usr/local/go export GOPATH=/Users/wangdante/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN # 使生效 source ~/.zshrc   打开新terminal\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  go env # 即可查看到GOPATH生效了 GO111MODULE=\u0026#34;on\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOBIN=\u0026#34;/usr/local/go/bin\u0026#34; GOCACHE=\u0026#34;/Users/wangdante/Library/Caches/go-build\u0026#34; GOENV=\u0026#34;/Users/wangdante/Library/Application Support/go/env\u0026#34; GOEXE=\u0026#34;\u0026#34; GOEXPERIMENT=\u0026#34;\u0026#34; GOFLAGS=\u0026#34;\u0026#34; GOHOSTARCH=\u0026#34;amd64\u0026#34; GOHOSTOS=\u0026#34;darwin\u0026#34; GOINSECURE=\u0026#34;\u0026#34; GOMODCACHE=\u0026#34;/Users/wangdante/go/pkg/mod\u0026#34; GONOPROXY=\u0026#34;\u0026#34; GONOSUMDB=\u0026#34;\u0026#34; GOOS=\u0026#34;darwin\u0026#34; GOPATH=\u0026#34;/Users/wangdante/go\u0026#34; GOPRIVATE=\u0026#34;\u0026#34; GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34; GOROOT=\u0026#34;/usr/local/go\u0026#34; GOSUMDB=\u0026#34;sum.golang.org\u0026#34; GOTMPDIR=\u0026#34;\u0026#34; GOTOOLDIR=\u0026#34;/usr/local/go/pkg/tool/darwin_amd64\u0026#34; GOVCS=\u0026#34;\u0026#34; GOVERSION=\u0026#34;go1.18.5\u0026#34; GCCGO=\u0026#34;gccgo\u0026#34; GOAMD64=\u0026#34;v1\u0026#34; AR=\u0026#34;ar\u0026#34; CC=\u0026#34;clang\u0026#34; CXX=\u0026#34;clang++\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; GOMOD=\u0026#34;/dev/null\u0026#34; GOWORK=\u0026#34;\u0026#34; CGO_CFLAGS=\u0026#34;-g -O2\u0026#34; CGO_CPPFLAGS=\u0026#34;\u0026#34; CGO_CXXFLAGS=\u0026#34;-g -O2\u0026#34; CGO_FFLAGS=\u0026#34;-g -O2\u0026#34; CGO_LDFLAGS=\u0026#34;-g -O2\u0026#34; PKG_CONFIG=\u0026#34;pkg-config\u0026#34; GOGCCFLAGS=\u0026#34;-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/9s/kn4nm_092wq6vp1crgf6q7th0000gn/T/go-build1296574441=/tmp/go-build -gno-record-gcc-switches -fno-common\u0026#34;   三、新建三个文件夹 1 2  mkdir -p $GOPATH/{bin,src,pkg}   四、运行第一个go程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  cd /Users/wangdante/go/src/ # (你的项目目录名称随便取) mkdir wjb cd wjb $ pwd /Users/wangdante/go/src/wjb #新建一个文件： vim test.go # 内容： package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } #保存并运行，方式两种 #方式一 $ go run test.go 1 ↵ Hello, World! #方式二 进入项目目录： sudo go install #PS：报错 #go: go.mod file not found in current directory or any parent directory; see \u0026#39;go help modules\u0026#39; #解决方法：与 golang 的包管理有关。 #go env -w GO111MODULE=auto 之后在GOPATH下面的bin目录生成一个hello的可执行文件 sh hello (#go build test.go)   五、go环境的卸载 步骤一： 删除/usr/local下的go目录(备注: 这个目录是安装go的时候自动生成的. 如果删除完, 使用 go version, 会报找不到go命令)\n步骤二： 删除Path环境变量 （备注: 这里,我只是想换一个版本, 所以, goPath还是需要的,所以不用删除）\n步骤三： 删除配置文件信息: 在 /etc/profile  或者 $HOME/.profile 或者 $HOME/.bahs_profile 或 ~/.zshrc 中删除bin的设置\n步骤四： 删除mac os x的安装包安装的文件, 删除 /etc/paths.d/go 文件\n(我只用了第一步, 重新安装, 其他都还继续使用)\n六、升级go版本 (升级前先卸载之前的golang版本)\n1 2 3 4 5 6  #之前 $ go version go version go1.17.11 darwin/arm64 #之后 $ go version 127 ↵ go version go1.18.5 darwin/amd64   步骤一、官网下载版本1.18.5 下载地址：https://golang.google.cn/dl/\n步骤二、删除/usr/local/go 删除/usr/local下的go目录(备注: 这个目录是安装go的时候自动生成的. 如果删除完, 使用 go version, 会报找不到go命令)\n步骤三、双击amd安装包 双击 go1.18.5.darwin-arm64.pkg 安装包，一路下一步\n之后go version验证\n","description":"整理在mac上的golang安装、配置及版本升级","id":13,"section":"stack","tags":["golang",""],"title":"golang安装、配置及版本升级","uri":"http://ingress.test1.com/en/stack/golang/get_started/"},{"content":"一、安装  pip 安装  pip install django\n安装成功后会有 django-admin 命令\n 创建新项目  django-admin startproject website(项目名)  开启项目  python manage.py startapp app \u0026ndash;不能重名  启动项目  python manage.py runserver  指定 IP+端口 启动项目  python manage.py runserver 0.0.0.0:8080 二、迁移文件操作 1、创建迁移文件内容 +添加表结构 app/models.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class AssessmentInfo(models.Model): \u0026#39;\u0026#39;\u0026#39;业务考核表\u0026#39;\u0026#39;\u0026#39; apply_id = models.IntegerField(\u0026#39;考核申请ID\u0026#39;, default=0, db_index=True) user = models.CharField(\u0026#39;用户名\u0026#39;, max_length=64, default=\u0026#39;\u0026#39;) userText = models.CharField(\u0026#39;中文名\u0026#39;, max_length=64, default=\u0026#39;\u0026#39;, db_column=\u0026#39;user_text\u0026#39;) leader = models.CharField(\u0026#39;业务考核人用户名\u0026#39;, max_length=64, default=\u0026#39;\u0026#39;) leaderText = models.CharField(\u0026#39;业务考核人中文名\u0026#39;, max_length=64, default=\u0026#39;\u0026#39;, db_column=\u0026#39;leader_text\u0026#39;) kpi = JSONField(\u0026#39;KPI\u0026#39;, default=[]) score = models.FloatField(\u0026#39;评分\u0026#39;, default=0) level = models.CharField(\u0026#39;等级\u0026#39;, max_length=10, default=\u0026#39;\u0026#39;) comment = models.TextField(\u0026#39;评语\u0026#39;, max_length=1000, default=\u0026#39;\u0026#39;) dept = models.CharField(\u0026#39;服务部门\u0026#39;, max_length=255, default=\u0026#39;\u0026#39;) position = models.CharField(\u0026#39;职位\u0026#39;, max_length=20, default=\u0026#39;\u0026#39;) entryDate = models.DateField(\u0026#39;入场时间\u0026#39;, blank=True, null=True, db_column=\u0026#39;entry_date\u0026#39;) # 0 - 未提交， 1- 未考核， 2 - 已考核 status = models.IntegerField(\u0026#39;状态\u0026#39;, default=0) created = models.DateTimeField(\u0026#39;创建时间\u0026#39;, auto_now_add=True) updated = models.DateTimeField(\u0026#39;更新时间\u0026#39;, auto_now=True) STATUS_OFF = 4 class Meta: db_table = \u0026#39;app_assessment_info\u0026#39; index_together = [ [\u0026#39;user\u0026#39;, \u0026#39;apply_id\u0026#39;], [\u0026#39;leader\u0026#39;, \u0026#39;apply_id\u0026#39;], ]   +修改表结构 app/models.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  class Migration(migrations.Migration): dependencies = [ (\u0026#39;UserManage\u0026#39;, \u0026#39;0001_initial\u0026#39;), ] operations = [ migrations.CreateModel( name=\u0026#39;Org\u0026#39;, fields=[ (\u0026#39;id\u0026#39;, models.AutoField(verbose_name=\u0026#39;ID\u0026#39;, serialize=False, auto_created=True, primary_key=True)), (\u0026#39;oid\u0026#39;, models.CharField(default=\u0026#39;\u0026#39;, max_length=20, db_index=True)), (\u0026#39;name\u0026#39;, models.CharField(default=\u0026#39;\u0026#39;, max_length=20)), (\u0026#39;level\u0026#39;, models.IntegerField(default=0)), (\u0026#39;parent\u0026#39;, models.IntegerField(default=0)), (\u0026#39;created\u0026#39;, models.DateTimeField(auto_now_add=True)), (\u0026#39;updated\u0026#39;, models.DateTimeField(auto_now=True)), ], options={ \u0026#39;db_table\u0026#39;: \u0026#39;user_manage_orgs\u0026#39;, }, bases=(models.Model, common.utils.models.toDictMixin), ), migrations.AddField( model_name=\u0026#39;user\u0026#39;, name=\u0026#39;entryDate\u0026#39;, field=models.DateField(null=True, db_column=\u0026#39;entry_date\u0026#39;, blank=True), ), migrations.AddField( model_name=\u0026#39;user\u0026#39;, name=\u0026#39;oid\u0026#39;, field=models.CharField(default=\u0026#39;\u0026#39;, max_length=20), ), migrations.AddField( model_name=\u0026#39;user\u0026#39;, name=\u0026#39;position\u0026#39;, field=models.CharField(default=\u0026#39;\u0026#39;, max_length=20), ), migrations.AlterField( model_name=\u0026#39;user\u0026#39;, name=\u0026#39;last_login\u0026#39;, field=models.DateTimeField(null=True, blank=True), ), ]   2、执行迁移文件命令 python manage.py makemigration\npython manage.py migrate 2.1 项目添加新的数据表 步骤一: 先刷新一下当前数据库的表结构，避免出现 table already exists\npython manage.py makemigrations\npython manage.py migrate app \u0026ndash;fake\npython manage.py migrate UserManage \u0026ndash;fake\n步骤二: 加表结构\n编写新的 models\n步骤三: 执行 migrate\npython manage.py makemigrations\npython manage.py migrate app\npython manage.py migrate UserManage\n三、orm 增、删、改、查操作  ORM：Object Relational Mapping(对象关系映射)，是使用面向对象的思维来操作数据库。\n *增加 方式一 ： 类名.objects.create() models.Person.objects.create(name=username,pwd=password) 方式二 ： obj=models.类（属性=XX） obj.save() 举子：\nperson_obj = models.Person(name=username,pwd=password)\nperson_obj.save() *删除 方式一 ： 类名.objects.get(xxx).delete() person_obj = models.Person.objects.get(id=ids) # 获取 person 对象\nperson_obj.delete() # 删除数据库中的记录 方式二 ： 类名.objects.filter(xxx).delete() ret = models.Person.objects.filter(id=ids) # filter() 根据条件进行过滤。\nret.delete() *修改 方式一 ： obj =类名.objects.get(‘xxx’)\nobj.zz = xx\nobj.save()\nperson_obj = models.Person.objects.get(id=id)\nperson_obj.name = usrname\nperson_obj.age = age\nperson_obj.birthday = bir\nperson_obj.save()\n方式二 ： 类名.objects.filter(‘xxx’).update(关键字（类中的属性）=值\u0026hellip;..) models.Person.objects.filter(id=id).update(name=usrname, age=age, birthday=bir) *查询 方式一 ： 类名.objects.all() 获取所有记录 models.Person.objects.all()\nmodels.Person.objects.filter(is_active=True)\n注意：单独查询要用 try except\ntry:\nauth=Author.objects.get(id=1)\nauth.delete()\nexcept:\nprint(删除失败) 四、路由 1 2 3 4 5 6 7 8 9 10 11 12  from django.conf.urls import include, url urlpatterns = [ url(r\u0026#39;^$\u0026#39;, Home), url(r\u0026#39;^wxlogin/$\u0026#39;, WXLogin), url(r\u0026#39;^app/\u0026#39;, include(\u0026#39;app.urls\u0026#39;)), url(r\u0026#39;^accounts/\u0026#39;, include(\u0026#39;UserManage.urls\u0026#39;)), url(r\u0026#39;^os_web/partners_kpi/api/wxlogin/$\u0026#39;, WXLogin), url(r\u0026#39;^os_web/partners_kpi/api/app/\u0026#39;, include(\u0026#39;app.urls\u0026#39;)), url(r\u0026#39;^os_web/partners_kpi/api/accounts/\u0026#39;, include(\u0026#39;UserManage.urls\u0026#39;)), ]   五、F 对象 用于模型类的 A 字段属性与 B 字段属性两者的比较，即操作数据库中某一列的值。\n通常是对数据库中的字段值在不获取的情况下进行操作。F 对象内置在数据包 django.db.models 中，所以使用时需要提前导入\n1 2  from django.db.models import F F(\u0026#39;字段名\u0026#39;)   在使用 F 对象进行查询的时候需要注意：\n一个 F() 对象代表了一个 Model 的字段的值；F 对象可以在没有实际访问数据库获取数据值的情况下对字段的值进行引用。\nDjango 支持对 F 对象引用字段的算术运算操作，并且运算符两边可以是具体的数值或者是另一个 F 对象，下面我们通过实例进一步认识 F 对象。\n1 2 3 4 5 6 7 8 9  from django.db.models import F from index.models import Book #给Book所有实例价格（retail_price）涨价20元 Book.objects.all().update(retail_price=F(\u0026#39;retail_price\u0026#39;)+20) #获取该列所有值并加20 #利用传统的方法实现涨价20元 books = models.Book.objects.all() for book in books: book.update(retail_price=book.retail_price+20) book.save()   通过上述实例可以看出，使用 F 对象相对传统的方法要简单的多。那么如何通过 F 对象实现两个字段值（列）之间的比较呢？实例如下所示：\n1 2 3 4  #对数据库中两个字段的值进行比较，列出哪儿些书的零售价高于定价 books = Book.objects.filter(retail_price__gt=F(\u0026#39;price\u0026#39;)) for book in books: print(book.title, \u0026#39;定价:\u0026#39;, book.price, \u0026#39;现价:\u0026#39;, book.retail_price)   六、Q 对象 相比 F 对象更加复杂一点，它主要应用于包含逻辑运算的复杂查询。Q 对象把关键字参数封装在一起，并传递给 filter、exclude、get 等查询的方法。多个 Q 对象之间可以使用\u0026amp;或者|运算符组合（符号分别表示与和或的关系），从而产生一个新的 Q 对象。当然也可以使用~（非）运算符来取反，从而实现 NOT 查询。\nQ 对象的导入方式如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13  from django.db.models import Q from index.models import Book #查找c语言中文网出版的书或价格低于35的书 Book.objects.filter(Q(retail_price__lt=35)|Q(pub_id=\u0026#39;2\u0026#39;))#两个Q对象是或者的逻辑关系 #查找不是c语言中文出版的书且价格低于45的书 Book.objects.filter(Q(retail_price__lt=45)\u0026amp;~Q(pub_id=\u0026#39;2\u0026#39;))#条件1成立条件2不成立 q = Q() if applyId: q \u0026amp;= Q(apply_id=applyId) if status: q \u0026amp;= Q(status=status) if applyIdList: q \u0026amp;= ~Q(apply_id__in=applyIdList)   Q 对象也可以与类属性的字段名组合在一起使用，但是在这种情况下，Django 规定，Q 对象必须放在 前面，示例如下：\n1 2  Book.objects.filter(Q(price__lte=100),title__icontains=\u0026#34;p\u0026#34;)#组合使用 \u0026lt;QuerySet [\u0026lt;Book: Book object (1)\u0026gt;]\u0026gt;   常见的运算符：\n\u0026amp; 与操作\n| 或操作 Q(market_pricelt=50) | Q(market_pricegt=20)\n~ 非操作\nexact 判断，大小写敏感\ncontains 是否包含，大小写敏感\nstartwith 以什么值开头，大小写敏感\nendwith 以什么值结束，大小写敏感\nin 是否在哎包含的范围内 如 ： filter(status__in=[1, 2])\n常见的比较运算符：\ngt 大于 如：filter(num__gt=0)\ngte 大于等于\nlt 小于\nlte 小于等于\n七、聚合查询 1、整表聚合 语法：\n聚合函数：Sum,Avg,Count,Max,Min\n语法：MyModel.objects.aggregate(结果变量名=聚合函数(\u0026lsquo;列\u0026rsquo;))\n返回结果：结果变量名和值组成的字典\n格式为：{\u0026ldquo;结果变量名\u0026rdquo;:值}\n1 2 3 4  from django.db.models import * #或from django.db.models import Count Book.objects.aggregate(res=Count(\u0026#39;id\u0026#39;)) {\u0026#39;res\u0026#39;:4}   2、分组聚合 “先分组（.values），再聚合(.annotate)”\nannotate\n使用：QuerySet.annotate(结果变量名=聚合函数(\u0026lsquo;列\u0026rsquo;))\n返回值：QuerySet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # 先分组 query_set = Book.objects.values(‘pub’) # 再聚合 QuerySet.annotate(名=聚合函数(\u0026#39;列\u0026#39;)) querySetS = AssessmentInfo.objects.filter(q).values(\u0026#39;level\u0026#39;) classNum = querySetS.annotate(res=Count(\u0026#39;id\u0026#39;)) for i in classNum: if i.get(\u0026#39;level\u0026#39;) == \u0026#39;S\u0026#39;: temp[\u0026#39;Snum\u0026#39;] = i.get(\u0026#39;res\u0026#39;, 0) elif i.get(\u0026#39;level\u0026#39;) == \u0026#39;A\u0026#39;: temp[\u0026#39;Anum\u0026#39;] = i.get(\u0026#39;res\u0026#39;, 0) elif i.get(\u0026#39;level\u0026#39;) == \u0026#39;B\u0026#39;: temp[\u0026#39;Bnum\u0026#39;] = i.get(\u0026#39;res\u0026#39;, 0) elif i.get(\u0026#39;level\u0026#39;) == \u0026#39;C\u0026#39;: temp[\u0026#39;Cnum\u0026#39;] = i.get(\u0026#39;res\u0026#39;, 0) elif i.get(\u0026#39;level\u0026#39;) == \u0026#39;D\u0026#39;: temp[\u0026#39;Dnum\u0026#39;] = i.get(\u0026#39;res\u0026#39;, 0)   八、执行原生 sql .query\n执行原生 sql：\n1 2  MyModel.objects.raw(sql语句，拼接参数) s1=Book.objects.raw(\u0026#39;select * from bookstore_book \u0026#39;)   九、关系映射 1、一对一：OneToOneField(类名,on_delete=xxx) 级联删除：\n1 models.CASCADE 同时删除\n2 models.PROTESCT 不能删除\n3 SET_NULL ForeignKey 为 null ，null=true\n4 SET_DEFAULT 外键设置默认值\n开启应用：步骤 1、2\n1、python manager.py startapp xxx\n2、settings.py -》INSTALLED_APPS=[\n.\n.\n.\n\u0026lsquo;XXX\u0026rsquo;\n]\n1 2 3 4 5 6 7 8 9 10 11 12  from django.db import models class Author(models.Model): name=models.CharField(\u0026#39;姓名\u0026#39;,max_length=11) class Wife(models.Model): name=models.CharField(\u0026#39;姓名\u0026#39;,max_length=11) author=models.OneToOneField(Author,on_delete=models.CASCADE) 正向查询：谁有外键，先查谁 from .models import wife wife=wife.objects.get(name=\u0026#39;王夫人\u0026#39;) print(wife.name,\u0026#39;的老公是\u0026#39;,wife.author.name) 反向查询：没有外键属性--反过来类名小写 print(author.wife.name)   2、一对多：ForeignField(类名,on_delete=xxx) 1 2 3 4 5 6 7 8 9  from django.db import models class Publisher(models.Model): name=models.CharField(\u0026#39;姓名\u0026#39;,max_length=11) class Book(models.Model): title=models.CharField(\u0026#39;姓名\u0026#39;,max_length=11) author=models.ForeignField(Publisher,on_delete=models.CASCADE) pub1=Publisher.objects.create(name=\u0026#39;清大学出版社\u0026#39;) Book.objects.create(title=\u0026#39;\u0026#39;C++,publisher=pub1)   十、cookie 和 session 的使用 1、cookie 以键-值对的形式\n每次向服务器发请求时，都会携带 cookie 给服务器\n1 2 3 4  HttpResponse.set_cookie(key,value=\u0026#39;\u0026#39;,max_age=None,expires=None) res=HttpResponse(\u0026#39;set cookie is ok\u0026#39;) res.set_cookie(\u0026#39;uname\u0026#39;,\u0026#39;gxn\u0026#39;,3600) return res   删除：\n1  HttpResponse.delete_cookie(key)   获取：\n1 2  request.COOKIES 字典(dict) request.COOKIES.get(\u0026#39;cookied名\u0026#39;,\u0026#39;默认值\u0026#39;\u0026#39;)   2、session 生成独立的存储空间（格子）sessionID-\u0026gt;借助 cookie 存储\nsession 要想成:必须有 cookie,session 数据很难被改，安全\n2.1 session 配置： 1 2 3 4 5 6 7  settings.py中:INSTALLED_APPS=[ \u0026#39;django.contrib.sessions\u0026#39;, ] 向MIDDLEWARE列表添加： MIDDLEWARE=[ \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, ]   2.2 session 配置项： settings.py 中相关配置项:\n1 2  SESSION_COOKIE_AGE=60*60*24*2*2 SESSION_EXPIRE_AT_BROWSER_CLOSE=True   浏览器关闭 session 失效\n定期清理 session\n1  python manage.py clearsessions   每晚定时任务，可删除过期的 session 数据\n2.3 session 使用： 保存：\n1 2 3 4 5  request.session[\u0026#39;KEY\u0026#39;]=VALUE def set_session(request): request.session[\u0026#39;uname\u0026#39;]=\u0026#39;wjb\u0026#39; return HttpResponse(\u0026#39;set sesssion is ok\u0026#39;)   获取：\n1 2 3 4 5 6  request.session[\u0026#39;KEY\u0026#39;] request.session.get(\u0026#39;KEY\u0026#39;,\u0026#39;默认值\u0026#39;) def get_session(request): value=request.session[\u0026#39;uname\u0026#39;] return=HttpResponse(\u0026#39;session value is %s\u0026#39;%(value))   ps:\n迁移文件防止报错:\ntable exists\n解决方法:\n1 2  python manage.py makemigrations python manage.py migrate app --fake   app 名称去 settings.py 中查看注册名称\n同时删除 django_migrations 表中的数据\n上传文件中文编码报错:\nUnicodeDecodeError: \u0026lsquo;ascii\u0026rsquo; codec can\u0026rsquo;t decode byte 0xe6 in position 260: ordinal not in range(128)\n解决方法:\n1 2 3 4 5  import sys # 设置中文编码 reload(sys) sys.setdefaultencoding(\u0026#39;utf8\u0026#39;)   ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":14,"section":"posts","tags":["shortcode"],"title":"django框架","uri":"http://ingress.test1.com/en/posts/django/"},{"content":"Code Syntax Highlighting123123123 Verify the following code blocks render as code blocks and highlight properly.\nMore about tuning syntax highlighting is the Hugo documentation.\nDiff 1 2 3 4 5 6 7 8 9 10  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line   *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line Makefile CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I. 1 2 3 4 5  CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I.   JSON 1 2 3  {\u0026#34;employees\u0026#34;:[ {\u0026#34;firstName\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Doe\u0026#34;}, ]}   Markdown 1 2 3  **bold** *italics* [link](www.example.com)   JavaScript 1  document.write(\u0026#39;Hello, world!\u0026#39;);   CSS 1 2 3  body { background-color: red; }   Objective C 1 2 3 4 5 6  #import \u0026lt;stdio.h\u0026gt;  int main (void) { printf (\u0026#34;Hello world!\\n\u0026#34;); }   Python 1  print \u0026#34;Hello, world!\u0026#34;   XML 1 2 3 4 5  \u0026lt;employees\u0026gt; \u0026lt;employee\u0026gt; \u0026lt;firstName\u0026gt;John\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;Doe\u0026lt;/lastName\u0026gt; \u0026lt;/employee\u0026gt; \u0026lt;/employees\u0026gt;   Perl 1  print \u0026#34;Hello, World!\\n\u0026#34;;   Bash 1  echo \u0026#34;Hello World\u0026#34;   PHP 1  \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;  CoffeeScript 1  console.log(“Hello world!”);   C# 1 2 3 4 5 6 7 8  using System; class Program { public static void Main(string[] args) { Console.WriteLine(\u0026#34;Hello, world!\u0026#34;); } }   C++ 1 2 3 4 5 6 7  #include \u0026lt;iostream.h\u0026gt; main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;; return 0; }   SQL 1 2  SELECTcolumn_name,column_nameFROMtable_name;  Go 1 2 3 4 5  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) }   Ruby 1  puts \u0026#34;Hello, world!\u0026#34;   Java 1 2 3 4 5 6 7 8 9 10 11 12  import javax.swing.JFrame; //Importing class JFrame import javax.swing.JLabel; //Importing class JLabel public class HelloWorld { public static void main(String[] args) { JFrame frame = new JFrame(); //Creating frame  frame.setTitle(\u0026#34;Hi!\u0026#34;); //Setting title frame  frame.add(new JLabel(\u0026#34;Hello, world!\u0026#34;));//Adding text to frame  frame.pack(); //Setting size to smallest  frame.setLocationRelativeTo(null); //Centering frame  frame.setVisible(true); //Showing frame  } }   Latex Equation 1  \\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x).   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {x, y} as p from \u0026#39;point\u0026#39;; const ANSWER = 42; class Car extends Vehicle { constructor(speed, cost) { super(speed); var c = Symbol(\u0026#39;cost\u0026#39;); this[c] = cost; this.intro = `This is a car runs at ${speed}.`; } } for (let num of [1, 2, 3]) { console.log(num + 0b111110111); } function $initHighlight(block, flags) { try { if (block.className.search(/\\bno\\-highlight\\b/) != -1) return processBlock(block.function, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;; } catch (e) { /* handle exception */ var e4x = \u0026lt;div\u0026gt;Example \u0026lt;p\u0026gt;1234\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;; } for (var i = 0 / 2; i \u0026lt; classes.length; i++) { // \u0026#34;0 / 2\u0026#34; should not be parsed as regexp  if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } console.log(Array.every(classes, Boolean)); } export $initHighlight;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello world\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;vendor/prism.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;examples.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /********************************************************* * General */ pre[class*=\u0026#34;language-\u0026#34;], code { color: #5c6e74; font-size: 13px; text-shadow: none; font-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; } pre[class*=\u0026#34;language-\u0026#34;]::selection, code::selection { text-shadow: none; background: #b3d4fc; } @media print { pre[class*=\u0026#34;language-\u0026#34;], code { text-shadow: none; } } pre[class*=\u0026#34;language-\u0026#34;] { padding: 1em; margin: .5em 0; overflow: auto; background: #f8f5ec; } :not(pre) \u0026gt; code { padding: .1em .3em; border-radius: .3em; color: #db4c69; background: #f9f2f4; }   ","description":"Syntax highlighting test","id":15,"section":"posts","tags":["hugo"],"title":"Syntax highlighting","uri":"http://ingress.test1.com/en/posts/syntax-highlight/"},{"content":"Markdownify box This is boxmd shortcode Simple box This is **box** shortcode  Code tabs Make it easy to switch between different code\njava javascript  1  System.out.println(\u0026#39;Hello World!\u0026#39;);     1  console.log(\u0026#39;Hello World!\u0026#39;);       'use strict'; var containerId = JSON.parse(\"\\\"beee16b23b213409\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Tabs for general purpose Windows MacOS Ubuntu  Windows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n MacOS section Hello world!  Ubuntu section Great!    'use strict'; var containerId = JSON.parse(\"\\\"fe409973e7a41bce\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Expand   Expand me  Title contents     Expand me2  Title2 contents2   Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text  info text  warning text  error text  ","description":"tabs, code-tabs, expand, alert, warning, notice, img, box","id":16,"section":"posts","tags":["shortcode"],"title":"Shortcodes","uri":"http://ingress.test1.com/en/posts/shortcodes/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":17,"section":"posts","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"http://ingress.test1.com/en/posts/markdown-syntax/"},{"content":"We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)  Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026quot;math.html\u0026quot; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$\n","description":"A brief guide to setup KaTeX","id":18,"section":"posts","tags":null,"title":"Math Typesetting","uri":"http://ingress.test1.com/en/posts/math-typesetting/"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"Guide to emoji usage in Hugo","id":19,"section":"posts","tags":["emoji","gamoji","namoji","bamoji","amoji"],"title":"Emoji Support","uri":"http://ingress.test1.com/en/posts/emoji-support/"},{"content":"digraph G { subgraph cluster_0 { style=filled; color=lightgrey; node [style=filled,color=white]; a0 -\u0026gt; a1 -\u0026gt; a2 -\u0026gt; a3; label = \u0026quot;process #1\u0026quot;; } subgraph cluster_1 { node [style=filled]; b0 -\u0026gt; b1 -\u0026gt; b2 -\u0026gt; b3; label = \u0026quot;process #2\u0026quot;; color=blue } start -\u0026gt; a0; start -\u0026gt; b0; a1 -\u0026gt; b3; b2 -\u0026gt; a3; a3 -\u0026gt; a0; a3 -\u0026gt; end; b3 -\u0026gt; end; start [shape=Mdiamond]; end [shape=Msquare]; } ","description":"A hack to put Graphviz on the web.","id":20,"section":"posts","tags":[""],"title":"Viz support","uri":"http://ingress.test1.com/en/posts/test-viz/"},{"content":"{ \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]}, {\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;}, {}, {\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;} ]} ","description":"WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.","id":21,"section":"posts","tags":[""],"title":"Wavedrom support","uri":"http://ingress.test1.com/en/posts/test-wavedrom/"},{"content":"{ \u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [{ \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8] }] } } { \u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [ { \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot; }, { \u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;, \u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot; } ] } } ","description":"Simple yet flexible JavaScript charting for designers \u0026 developers","id":22,"section":"posts","tags":[""],"title":"Chart support","uri":"http://ingress.test1.com/en/posts/test-chartjs/"},{"content":"Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! Title: Here is a title A-\u0026gt;B: Normal line B--\u0026gt;C: Dashed line C-\u0026gt;\u0026gt;D: Open arrow D--\u0026gt;\u0026gt;A: Dashed open arrow ","description":"Generates UML sequence diagrams from simple text","id":23,"section":"posts","tags":[""],"title":"JS Sequence Diagram support","uri":"http://ingress.test1.com/en/posts/test-js-sequence-diagrams/"},{"content":"graph TD; A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; sequenceDiagram participant Alice participant Bob Alice-\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! graph TD A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u0026lt;\u0026lt;service\u0026gt;\u0026gt; int id size() } stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] pie \u0026quot;Dogs\u0026quot; : 386 \u0026quot;Cats\u0026quot; : 85 \u0026quot;Rats\u0026quot; : 15 ","description":"Generate diagrams, charts, graphs or flows from markdown-like text via javascript.","id":24,"section":"posts","tags":["diagram"],"title":"Mermaid support","uri":"http://ingress.test1.com/en/posts/test-mermaid/"},{"content":"When $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\n","description":"A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.","id":25,"section":"posts","tags":[""],"title":"MathJax support","uri":"http://ingress.test1.com/en/posts/test-mathjax/"},{"content":"The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $ Inline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","description":"KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.","id":26,"section":"posts","tags":[""],"title":"Katex support","uri":"http://ingress.test1.com/en/posts/test-katex/"},{"content":"st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank] e=\u0026gt;end: End|future:\u0026gt;http://www.google.com op1=\u0026gt;operation: My Operation|past op2=\u0026gt;operation: Stuff|current sub1=\u0026gt;subroutine: My Subroutine|invalid cond=\u0026gt;condition: Yes or No?|approved:\u0026gt;http://www.google.com c2=\u0026gt;condition: Good idea|rejected io=\u0026gt;inputoutput: catch something...|future st-\u0026gt;op1(right)-\u0026gt;cond cond(yes, right)-\u0026gt;c2 cond(no)-\u0026gt;sub1(left)-\u0026gt;op1 c2(yes)-\u0026gt;io-\u0026gt;e c2(no)-\u0026gt;op2-\u0026gt;e st=\u0026gt;start: Start e=\u0026gt;end: 需求变更备案 op1=\u0026gt;operation: 需求基线确定|past op2=\u0026gt;operation: 内部需求变更|current op3=\u0026gt;operation: 下一个版本|current op4=\u0026gt;operation: 与客户协商需求变更|current op5=\u0026gt;operation: 更新需求文档|current op6=\u0026gt;operation: 通知项目组开发和测试|current op7=\u0026gt;operation: 客户需求变更流程|current cond1=\u0026gt;condition: 是否对实际业务产生影响 cond2=\u0026gt;condition: 是否接受当前版本变更 st-\u0026gt;op1(right)-\u0026gt;op1(right)-\u0026gt;op2-\u0026gt;cond1 cond1(no)-\u0026gt;cond2 cond1(yes)-\u0026gt;op4-\u0026gt;op7 cond2(yes)-\u0026gt;op5 cond2(no)-\u0026gt;op3 op5-\u0026gt;op6 op6-\u0026gt;e 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/googgirl/article/details/108335574\n","description":"flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.","id":27,"section":"posts","tags":[""],"title":"Flowchart support","uri":"http://ingress.test1.com/en/posts/test-flowchart/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":28,"section":"gallery","tags":null,"title":"Cartoon","uri":"http://ingress.test1.com/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":29,"section":"gallery","tags":null,"title":"Photo","uri":"http://ingress.test1.com/en/gallery/photo/"},{"content":"jarvenwang 中国 Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":35,"section":"","tags":null,"title":"About","uri":"http://ingress.test1.com/en/about/"}]